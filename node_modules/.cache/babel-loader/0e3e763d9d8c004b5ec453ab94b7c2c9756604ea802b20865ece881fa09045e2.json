{"ast":null,"code":"console.log('hello');\n/* eslint-disable no-unused-expressions */\n/* eslint-disable no-sequences */\n//Converting colors to proper format\nfunction normalizeColor(hexCode) {\n  return [(hexCode >> 16 & 255) / 255, (hexCode >> 8 & 255) / 255, (255 & hexCode) / 255];\n}\n[\"SCREEN\", \"LINEAR_LIGHT\"].reduce((hexCode, t, n) => Object.assign(hexCode, {\n  [t]: n\n}), {});\n\n//Essential functionality of WebGl\n//t = width\n//n = height\nclass MiniGl {\n  constructor(canvas, width, height) {\n    let debug = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    const _miniGl = this,\n      debug_output = -1 !== document.location.search.toLowerCase().indexOf(\"debug=webgl\");\n    _miniGl.canvas = canvas, _miniGl.gl = _miniGl.canvas.getContext(\"webgl\", {\n      antialias: true\n    }), _miniGl.meshes = [];\n    const context = _miniGl.gl;\n    width && height && this.setSize(width, height), _miniGl.lastDebugMsg, _miniGl.debug = debug && debug_output ? function (e) {\n      const t = new Date();\n      t - _miniGl.lastDebugMsg > 1e3 && console.log(\"---\"), console.log(t.toLocaleTimeString() + Array(Math.max(0, 32 - e.length)).join(\" \") + e + \": \", ...Array.from(arguments).slice(1)), _miniGl.lastDebugMsg = t;\n    } : () => {}, Object.defineProperties(_miniGl, {\n      Material: {\n        enumerable: false,\n        value: class {\n          constructor(vertexShaders, fragments) {\n            let uniforms = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n            const material = this;\n            function getShaderByType(type, source) {\n              const shader = context.createShader(type);\n              return context.shaderSource(shader, source), context.compileShader(shader), context.getShaderParameter(shader, context.COMPILE_STATUS) || console.error(context.getShaderInfoLog(shader)), _miniGl.debug(\"Material.compileShaderSource\", {\n                source: source\n              }), shader;\n            }\n            function getUniformVariableDeclarations(uniforms, type) {\n              return Object.entries(uniforms).map(_ref => {\n                let [uniform, value] = _ref;\n                return value.getDeclaration(uniform, type);\n              }).join(\"\\n\");\n            }\n            material.uniforms = uniforms, material.uniformInstances = [];\n            const prefix = \"\\n              precision highp float;\\n            \";\n            material.vertexSource = `\\n              ${prefix}\\n              attribute vec4 position;\\n              attribute vec2 uv;\\n              attribute vec2 uvNorm;\\n              ${getUniformVariableDeclarations(_miniGl.commonUniforms, \"vertex\")}\\n              ${getUniformVariableDeclarations(uniforms, \"vertex\")}\\n              ${vertexShaders}\\n            `, material.Source = `\\n              ${prefix}\\n              ${getUniformVariableDeclarations(_miniGl.commonUniforms, \"fragment\")}\\n              ${getUniformVariableDeclarations(uniforms, \"fragment\")}\\n              ${fragments}\\n            `, material.vertexShader = getShaderByType(context.VERTEX_SHADER, material.vertexSource), material.fragmentShader = getShaderByType(context.FRAGMENT_SHADER, material.Source), material.program = context.createProgram(), context.attachShader(material.program, material.vertexShader), context.attachShader(material.program, material.fragmentShader), context.linkProgram(material.program), context.getProgramParameter(material.program, context.LINK_STATUS) || console.error(context.getProgramInfoLog(material.program)), context.useProgram(material.program), material.attachUniforms(void 0, _miniGl.commonUniforms), material.attachUniforms(void 0, material.uniforms);\n          }\n          //t = uniform\n          attachUniforms(name, uniforms) {\n            //n  = material\n            const material = this;\n            void 0 === name ? Object.entries(uniforms).forEach(_ref2 => {\n              let [name, uniform] = _ref2;\n              material.attachUniforms(name, uniform);\n            }) : \"array\" == uniforms.type ? uniforms.value.forEach((uniform, i) => material.attachUniforms(`${name}[${i}]`, uniform)) : \"struct\" == uniforms.type ? Object.entries(uniforms.value).forEach(_ref3 => {\n              let [uniform, i] = _ref3;\n              return material.attachUniforms(`${name}.${uniform}`, i);\n            }) : (_miniGl.debug(\"Material.attachUniforms\", {\n              name: name,\n              uniform: uniforms\n            }), material.uniformInstances.push({\n              uniform: uniforms,\n              location: context.getUniformLocation(material.program, name)\n            }));\n          }\n        }\n      },\n      Uniform: {\n        enumerable: !1,\n        value: class {\n          constructor(e) {\n            this.type = \"float\", Object.assign(this, e);\n            this.typeFn = {\n              float: \"1f\",\n              int: \"1i\",\n              vec2: \"2fv\",\n              vec3: \"3fv\",\n              vec4: \"4fv\",\n              mat4: \"Matrix4fv\"\n            }[this.type] || \"1f\", this.update();\n          }\n          update(value) {\n            void 0 !== this.value && context[`uniform${this.typeFn}`](value, 0 === this.typeFn.indexOf(\"Matrix\") ? this.transpose : this.value, 0 === this.typeFn.indexOf(\"Matrix\") ? this.value : null);\n          }\n          //e - name\n          //t - type\n          //n - length\n          getDeclaration(name, type, length) {\n            const uniform = this;\n            if (uniform.excludeFrom !== type) {\n              if (\"array\" === uniform.type) return uniform.value[0].getDeclaration(name, type, uniform.value.length) + `\\nconst int ${name}_length = ${uniform.value.length};`;\n              if (\"struct\" === uniform.type) {\n                let name_no_prefix = name.replace(\"u_\", \"\");\n                return name_no_prefix = name_no_prefix.charAt(0).toUpperCase() + name_no_prefix.slice(1), `uniform struct ${name_no_prefix} \n                                {\\n` + Object.entries(uniform.value).map(_ref4 => {\n                  let [name, uniform] = _ref4;\n                  return uniform.getDeclaration(name, type).replace(/^uniform/, \"\");\n                }).join(\"\") + `\\n} ${name}${length > 0 ? `[${length}]` : \"\"};`;\n              }\n              return `uniform ${uniform.type} ${name}${length > 0 ? `[${length}]` : \"\"};`;\n            }\n          }\n        }\n      },\n      PlaneGeometry: {\n        enumerable: !1,\n        value: class {\n          constructor(width, height, n, i, orientation) {\n            context.createBuffer(), this.attributes = {\n              position: new _miniGl.Attribute({\n                target: context.ARRAY_BUFFER,\n                size: 3\n              }),\n              uv: new _miniGl.Attribute({\n                target: context.ARRAY_BUFFER,\n                size: 2\n              }),\n              uvNorm: new _miniGl.Attribute({\n                target: context.ARRAY_BUFFER,\n                size: 2\n              }),\n              index: new _miniGl.Attribute({\n                target: context.ELEMENT_ARRAY_BUFFER,\n                size: 3,\n                type: context.UNSIGNED_SHORT\n              })\n            }, this.setTopology(n, i), this.setSize(width, height, orientation);\n          }\n          setTopology() {\n            let e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n            let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n            const n = this;\n            n.xSegCount = e, n.ySegCount = t, n.vertexCount = (n.xSegCount + 1) * (n.ySegCount + 1), n.quadCount = n.xSegCount * n.ySegCount * 2, n.attributes.uv.values = new Float32Array(2 * n.vertexCount), n.attributes.uvNorm.values = new Float32Array(2 * n.vertexCount), n.attributes.index.values = new Uint16Array(3 * n.quadCount);\n            for (let e = 0; e <= n.ySegCount; e++) for (let t = 0; t <= n.xSegCount; t++) {\n              const i = e * (n.xSegCount + 1) + t;\n              if (n.attributes.uv.values[2 * i] = t / n.xSegCount, n.attributes.uv.values[2 * i + 1] = 1 - e / n.ySegCount, n.attributes.uvNorm.values[2 * i] = t / n.xSegCount * 2 - 1, n.attributes.uvNorm.values[2 * i + 1] = 1 - e / n.ySegCount * 2, t < n.xSegCount && e < n.ySegCount) {\n                const s = e * n.xSegCount + t;\n                n.attributes.index.values[6 * s] = i, n.attributes.index.values[6 * s + 1] = i + 1 + n.xSegCount, n.attributes.index.values[6 * s + 2] = i + 1, n.attributes.index.values[6 * s + 3] = i + 1, n.attributes.index.values[6 * s + 4] = i + 1 + n.xSegCount, n.attributes.index.values[6 * s + 5] = i + 2 + n.xSegCount;\n              }\n            }\n            n.attributes.uv.update(), n.attributes.uvNorm.update(), n.attributes.index.update(), _miniGl.debug(\"Geometry.setTopology\", {\n              uv: n.attributes.uv,\n              uvNorm: n.attributes.uvNorm,\n              index: n.attributes.index\n            });\n          }\n          setSize() {\n            let width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n            let height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n            let orientation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"xz\";\n            const geometry = this;\n            geometry.width = width, geometry.height = height, geometry.orientation = orientation, geometry.attributes.position.values && geometry.attributes.position.values.length === 3 * geometry.vertexCount || (geometry.attributes.position.values = new Float32Array(3 * geometry.vertexCount));\n            const o = width / -2,\n              r = height / -2,\n              segment_width = width / geometry.xSegCount,\n              segment_height = height / geometry.ySegCount;\n            for (let yIndex = 0; yIndex <= geometry.ySegCount; yIndex++) {\n              const t = r + yIndex * segment_height;\n              for (let xIndex = 0; xIndex <= geometry.xSegCount; xIndex++) {\n                const r = o + xIndex * segment_width,\n                  l = yIndex * (geometry.xSegCount + 1) + xIndex;\n                geometry.attributes.position.values[3 * l + \"xyz\".indexOf(orientation[0])] = r, geometry.attributes.position.values[3 * l + \"xyz\".indexOf(orientation[1])] = -t;\n              }\n            }\n            geometry.attributes.position.update(), _miniGl.debug(\"Geometry.setSize\", {\n              position: geometry.attributes.position\n            });\n          }\n        }\n      },\n      Mesh: {\n        enumerable: !1,\n        value: class {\n          constructor(geometry, material) {\n            const mesh = this;\n            mesh.geometry = geometry, mesh.material = material, mesh.wireframe = !1, mesh.attributeInstances = [], Object.entries(mesh.geometry.attributes).forEach(_ref5 => {\n              let [e, attribute] = _ref5;\n              mesh.attributeInstances.push({\n                attribute: attribute,\n                location: attribute.attach(e, mesh.material.program)\n              });\n            }), _miniGl.meshes.push(mesh), _miniGl.debug(\"Mesh.constructor\", {\n              mesh: mesh\n            });\n          }\n          draw() {\n            context.useProgram(this.material.program), this.material.uniformInstances.forEach(_ref6 => {\n              let {\n                uniform: e,\n                location: t\n              } = _ref6;\n              return e.update(t);\n            }), this.attributeInstances.forEach(_ref7 => {\n              let {\n                attribute: e,\n                location: t\n              } = _ref7;\n              return e.use(t);\n            }), context.drawElements(this.wireframe ? context.LINES : context.TRIANGLES, this.geometry.attributes.index.values.length, context.UNSIGNED_SHORT, 0);\n          }\n          remove() {\n            _miniGl.meshes = _miniGl.meshes.filter(e => e != this);\n          }\n        }\n      },\n      Attribute: {\n        enumerable: !1,\n        value: class {\n          constructor(e) {\n            this.type = context.FLOAT, this.normalized = !1, this.buffer = context.createBuffer(), Object.assign(this, e), this.update();\n          }\n          update() {\n            void 0 !== this.values && (context.bindBuffer(this.target, this.buffer), context.bufferData(this.target, this.values, context.STATIC_DRAW));\n          }\n          attach(e, t) {\n            const n = context.getAttribLocation(t, e);\n            return this.target === context.ARRAY_BUFFER && (context.enableVertexAttribArray(n), context.vertexAttribPointer(n, this.size, this.type, this.normalized, 0, 0)), n;\n          }\n          use(e) {\n            context.bindBuffer(this.target, this.buffer), this.target === context.ARRAY_BUFFER && (context.enableVertexAttribArray(e), context.vertexAttribPointer(e, this.size, this.type, this.normalized, 0, 0));\n          }\n        }\n      }\n    });\n    const a = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\n    _miniGl.commonUniforms = {\n      projectionMatrix: new _miniGl.Uniform({\n        type: \"mat4\",\n        value: a\n      }),\n      modelViewMatrix: new _miniGl.Uniform({\n        type: \"mat4\",\n        value: a\n      }),\n      resolution: new _miniGl.Uniform({\n        type: \"vec2\",\n        value: [1, 1]\n      }),\n      aspectRatio: new _miniGl.Uniform({\n        type: \"float\",\n        value: 1\n      })\n    };\n  }\n  setSize() {\n    let e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 640;\n    let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 480;\n    this.width = e, this.height = t, this.canvas.width = e, this.canvas.height = t, this.gl.viewport(0, 0, e, t), this.commonUniforms.resolution.value = [e, t], this.commonUniforms.aspectRatio.value = e / t, this.debug(\"MiniGL.setSize\", {\n      width: e,\n      height: t\n    });\n  }\n  //left, right, top, bottom, near, far\n  setOrthographicCamera() {\n    let e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    let n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    let i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : -2e3;\n    let s = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 2e3;\n    this.commonUniforms.projectionMatrix.value = [2 / this.width, 0, 0, 0, 0, 2 / this.height, 0, 0, 0, 0, 2 / (i - s), 0, e, t, n, 1], this.debug(\"setOrthographicCamera\", this.commonUniforms.projectionMatrix.value);\n  }\n  render() {\n    this.gl.clearColor(0, 0, 0, 0), this.gl.clearDepth(1), this.meshes.forEach(e => e.draw());\n  }\n}\n\n//Sets initial properties\nfunction e(object, propertyName, val) {\n  return propertyName in object ? Object.defineProperty(object, propertyName, {\n    value: val,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : object[propertyName] = val, object;\n}\n\n//Gradient object\nclass Gradient {\n  constructor() {\n    e(this, \"el\", void 0), e(this, \"cssVarRetries\", 0), e(this, \"maxCssVarRetries\", 200), e(this, \"angle\", 0), e(this, \"isLoadedClass\", !1), e(this, \"isScrolling\", !1), /*e(this, \"isStatic\", o.disableAmbientAnimations()),*/e(this, \"scrollingTimeout\", void 0), e(this, \"scrollingRefreshDelay\", 200), e(this, \"isIntersecting\", !1), e(this, \"shaderFiles\", void 0), e(this, \"vertexShader\", void 0), e(this, \"sectionColors\", void 0), e(this, \"computedCanvasStyle\", void 0), e(this, \"conf\", void 0), e(this, \"uniforms\", void 0), e(this, \"t\", 1253106), e(this, \"last\", 0), e(this, \"width\", void 0), e(this, \"minWidth\", 1111), e(this, \"height\", 600), e(this, \"xSegCount\", void 0), e(this, \"ySegCount\", void 0), e(this, \"mesh\", void 0), e(this, \"material\", void 0), e(this, \"geometry\", void 0), e(this, \"minigl\", void 0), e(this, \"scrollObserver\", void 0), e(this, \"amp\", 320), e(this, \"seed\", 5), e(this, \"freqX\", 14e-5), e(this, \"freqY\", 29e-5), e(this, \"freqDelta\", 1e-5), e(this, \"activeColors\", [1, 1, 1, 1]), e(this, \"isMetaKey\", !1), e(this, \"isGradientLegendVisible\", !1), e(this, \"isMouseDown\", !1), e(this, \"handleScroll\", () => {\n      clearTimeout(this.scrollingTimeout), this.scrollingTimeout = setTimeout(this.handleScrollEnd, this.scrollingRefreshDelay), this.isGradientLegendVisible && this.hideGradientLegend(), this.conf.playing && (this.isScrolling = !0, this.pause());\n    }), e(this, \"handleScrollEnd\", () => {\n      this.isScrolling = !1, this.isIntersecting && this.play();\n    }), e(this, \"resize\", () => {\n      this.width = window.innerWidth, this.minigl.setSize(this.width, this.height), this.minigl.setOrthographicCamera(), this.xSegCount = Math.ceil(this.width * this.conf.density[0]), this.ySegCount = Math.ceil(this.height * this.conf.density[1]), this.mesh.geometry.setTopology(this.xSegCount, this.ySegCount), this.mesh.geometry.setSize(this.width, this.height), this.mesh.material.uniforms.u_shadow_power.value = this.width < 600 ? 5 : 6;\n    }), e(this, \"handleMouseDown\", e => {\n      this.isGradientLegendVisible && (this.isMetaKey = e.metaKey, this.isMouseDown = !0, !1 === this.conf.playing && requestAnimationFrame(this.animate));\n    }), e(this, \"handleMouseUp\", () => {\n      this.isMouseDown = !1;\n    }), e(this, \"animate\", e => {\n      if (!this.shouldSkipFrame(e) || this.isMouseDown) {\n        if (this.t += Math.min(e - this.last, 1e3 / 15), this.last = e, this.isMouseDown) {\n          let e = 160;\n          this.isMetaKey && (e = -160), this.t += e;\n        }\n        this.mesh.material.uniforms.u_time.value = this.t, this.minigl.render();\n      }\n      if (0 !== this.last && this.isStatic) return this.minigl.render(), void this.disconnect();\n      ( /*this.isIntersecting && */this.conf.playing || this.isMouseDown) && requestAnimationFrame(this.animate);\n    }), e(this, \"addIsLoadedClass\", () => {\n      /*this.isIntersecting && */!this.isLoadedClass && (this.isLoadedClass = !0, this.el.classList.add(\"isLoaded\"), setTimeout(() => {\n        this.el.parentElement.classList.add(\"isLoaded\");\n      }, 3e3));\n    }), e(this, \"pause\", () => {\n      this.conf.playing = false;\n    }), e(this, \"play\", () => {\n      requestAnimationFrame(this.animate), this.conf.playing = true;\n    }), e(this, \"initGradient\", selector => {\n      this.el = document.querySelector(selector);\n      this.connect();\n      return this;\n    });\n  }\n  async connect() {\n    this.shaderFiles = {\n      vertex: \"varying vec3 v_color;\\n\\nvoid main() {\\n  float time = u_time * u_global.noiseSpeed;\\n\\n  vec2 noiseCoord = resolution * uvNorm * u_global.noiseFreq;\\n\\n  vec2 st = 1. - uvNorm.xy;\\n\\n  //\\n  // Tilting the plane\\n  //\\n\\n  // Front-to-back tilt\\n  float tilt = resolution.y / 2.0 * uvNorm.y;\\n\\n  // Left-to-right angle\\n  float incline = resolution.x * uvNorm.x / 2.0 * u_vertDeform.incline;\\n\\n  // Up-down shift to offset incline\\n  float offset = resolution.x / 2.0 * u_vertDeform.incline * mix(u_vertDeform.offsetBottom, u_vertDeform.offsetTop, uv.y);\\n\\n  //\\n  // Vertex noise\\n  //\\n\\n  float noise = snoise(vec3(\\n    noiseCoord.x * u_vertDeform.noiseFreq.x + time * u_vertDeform.noiseFlow,\\n    noiseCoord.y * u_vertDeform.noiseFreq.y,\\n    time * u_vertDeform.noiseSpeed + u_vertDeform.noiseSeed\\n  )) * u_vertDeform.noiseAmp;\\n\\n  // Fade noise to zero at edges\\n  noise *= 1.0 - pow(abs(uvNorm.y), 2.0);\\n\\n  // Clamp to 0\\n  noise = max(0.0, noise);\\n\\n  vec3 pos = vec3(\\n    position.x,\\n    position.y + tilt + incline + noise - offset,\\n    position.z\\n  );\\n\\n  //\\n  // Vertex color, to be passed to fragment shader\\n  //\\n\\n  if (u_active_colors[0] == 1.) {\\n    v_color = u_baseColor;\\n  }\\n\\n  for (int i = 0; i < u_waveLayers_length; i++) {\\n    if (u_active_colors[i + 1] == 1.) {\\n      WaveLayers layer = u_waveLayers[i];\\n\\n      float noise = smoothstep(\\n        layer.noiseFloor,\\n        layer.noiseCeil,\\n        snoise(vec3(\\n          noiseCoord.x * layer.noiseFreq.x + time * layer.noiseFlow,\\n          noiseCoord.y * layer.noiseFreq.y,\\n          time * layer.noiseSpeed + layer.noiseSeed\\n        )) / 2.0 + 0.5\\n      );\\n\\n      v_color = blendNormal(v_color, layer.color, pow(noise, 4.));\\n    }\\n  }\\n\\n  //\\n  // Finish\\n  //\\n\\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\\n}\",\n      noise: \"//\\n// Description : Array and textureless GLSL 2D/3D/4D simplex\\n//               noise functions.\\n//      Author : Ian McEwan, Ashima Arts.\\n//  Maintainer : stegu\\n//     Lastmod : 20110822 (ijm)\\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\\n//               Distributed under the MIT License. See LICENSE file.\\n//               https://github.com/ashima/webgl-noise\\n//               https://github.com/stegu/webgl-noise\\n//\\n\\nvec3 mod289(vec3 x) {\\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\\n}\\n\\nvec4 mod289(vec4 x) {\\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\\n}\\n\\nvec4 permute(vec4 x) {\\n    return mod289(((x*34.0)+1.0)*x);\\n}\\n\\nvec4 taylorInvSqrt(vec4 r)\\n{\\n  return 1.79284291400159 - 0.85373472095314 * r;\\n}\\n\\nfloat snoise(vec3 v)\\n{\\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\\n\\n// First corner\\n  vec3 i  = floor(v + dot(v, C.yyy) );\\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\\n\\n// Other corners\\n  vec3 g = step(x0.yzx, x0.xyz);\\n  vec3 l = 1.0 - g;\\n  vec3 i1 = min( g.xyz, l.zxy );\\n  vec3 i2 = max( g.xyz, l.zxy );\\n\\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\\n  vec3 x1 = x0 - i1 + C.xxx;\\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\\n\\n// Permutations\\n  i = mod289(i);\\n  vec4 p = permute( permute( permute(\\n            i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\\n          + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\\n          + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\\n\\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\\n  float n_ = 0.142857142857; // 1.0/7.0\\n  vec3  ns = n_ * D.wyz - D.xzx;\\n\\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\\n\\n  vec4 x_ = floor(j * ns.z);\\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\\n\\n  vec4 x = x_ *ns.x + ns.yyyy;\\n  vec4 y = y_ *ns.x + ns.yyyy;\\n  vec4 h = 1.0 - abs(x) - abs(y);\\n\\n  vec4 b0 = vec4( x.xy, y.xy );\\n  vec4 b1 = vec4( x.zw, y.zw );\\n\\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\\n  vec4 s0 = floor(b0)*2.0 + 1.0;\\n  vec4 s1 = floor(b1)*2.0 + 1.0;\\n  vec4 sh = -step(h, vec4(0.0));\\n\\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\\n\\n  vec3 p0 = vec3(a0.xy,h.x);\\n  vec3 p1 = vec3(a0.zw,h.y);\\n  vec3 p2 = vec3(a1.xy,h.z);\\n  vec3 p3 = vec3(a1.zw,h.w);\\n\\n//Normalise gradients\\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\\n  p0 *= norm.x;\\n  p1 *= norm.y;\\n  p2 *= norm.z;\\n  p3 *= norm.w;\\n\\n// Mix final noise value\\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\\n  m = m * m;\\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\\n                                dot(p2,x2), dot(p3,x3) ) );\\n}\",\n      blend: \"//\\n// https://github.com/jamieowen/glsl-blend\\n//\\n\\n// Normal\\n\\nvec3 blendNormal(vec3 base, vec3 blend) {\\n\\treturn blend;\\n}\\n\\nvec3 blendNormal(vec3 base, vec3 blend, float opacity) {\\n\\treturn (blendNormal(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n// Screen\\n\\nfloat blendScreen(float base, float blend) {\\n\\treturn 1.0-((1.0-base)*(1.0-blend));\\n}\\n\\nvec3 blendScreen(vec3 base, vec3 blend) {\\n\\treturn vec3(blendScreen(base.r,blend.r),blendScreen(base.g,blend.g),blendScreen(base.b,blend.b));\\n}\\n\\nvec3 blendScreen(vec3 base, vec3 blend, float opacity) {\\n\\treturn (blendScreen(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n// Multiply\\n\\nvec3 blendMultiply(vec3 base, vec3 blend) {\\n\\treturn base*blend;\\n}\\n\\nvec3 blendMultiply(vec3 base, vec3 blend, float opacity) {\\n\\treturn (blendMultiply(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n// Overlay\\n\\nfloat blendOverlay(float base, float blend) {\\n\\treturn base<0.5?(2.0*base*blend):(1.0-2.0*(1.0-base)*(1.0-blend));\\n}\\n\\nvec3 blendOverlay(vec3 base, vec3 blend) {\\n\\treturn vec3(blendOverlay(base.r,blend.r),blendOverlay(base.g,blend.g),blendOverlay(base.b,blend.b));\\n}\\n\\nvec3 blendOverlay(vec3 base, vec3 blend, float opacity) {\\n\\treturn (blendOverlay(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n// Hard light\\n\\nvec3 blendHardLight(vec3 base, vec3 blend) {\\n\\treturn blendOverlay(blend,base);\\n}\\n\\nvec3 blendHardLight(vec3 base, vec3 blend, float opacity) {\\n\\treturn (blendHardLight(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n// Soft light\\n\\nfloat blendSoftLight(float base, float blend) {\\n\\treturn (blend<0.5)?(2.0*base*blend+base*base*(1.0-2.0*blend)):(sqrt(base)*(2.0*blend-1.0)+2.0*base*(1.0-blend));\\n}\\n\\nvec3 blendSoftLight(vec3 base, vec3 blend) {\\n\\treturn vec3(blendSoftLight(base.r,blend.r),blendSoftLight(base.g,blend.g),blendSoftLight(base.b,blend.b));\\n}\\n\\nvec3 blendSoftLight(vec3 base, vec3 blend, float opacity) {\\n\\treturn (blendSoftLight(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n// Color dodge\\n\\nfloat blendColorDodge(float base, float blend) {\\n\\treturn (blend==1.0)?blend:min(base/(1.0-blend),1.0);\\n}\\n\\nvec3 blendColorDodge(vec3 base, vec3 blend) {\\n\\treturn vec3(blendColorDodge(base.r,blend.r),blendColorDodge(base.g,blend.g),blendColorDodge(base.b,blend.b));\\n}\\n\\nvec3 blendColorDodge(vec3 base, vec3 blend, float opacity) {\\n\\treturn (blendColorDodge(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n// Color burn\\n\\nfloat blendColorBurn(float base, float blend) {\\n\\treturn (blend==0.0)?blend:max((1.0-((1.0-base)/blend)),0.0);\\n}\\n\\nvec3 blendColorBurn(vec3 base, vec3 blend) {\\n\\treturn vec3(blendColorBurn(base.r,blend.r),blendColorBurn(base.g,blend.g),blendColorBurn(base.b,blend.b));\\n}\\n\\nvec3 blendColorBurn(vec3 base, vec3 blend, float opacity) {\\n\\treturn (blendColorBurn(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n// Vivid Light\\n\\nfloat blendVividLight(float base, float blend) {\\n\\treturn (blend<0.5)?blendColorBurn(base,(2.0*blend)):blendColorDodge(base,(2.0*(blend-0.5)));\\n}\\n\\nvec3 blendVividLight(vec3 base, vec3 blend) {\\n\\treturn vec3(blendVividLight(base.r,blend.r),blendVividLight(base.g,blend.g),blendVividLight(base.b,blend.b));\\n}\\n\\nvec3 blendVividLight(vec3 base, vec3 blend, float opacity) {\\n\\treturn (blendVividLight(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n// Lighten\\n\\nfloat blendLighten(float base, float blend) {\\n\\treturn max(blend,base);\\n}\\n\\nvec3 blendLighten(vec3 base, vec3 blend) {\\n\\treturn vec3(blendLighten(base.r,blend.r),blendLighten(base.g,blend.g),blendLighten(base.b,blend.b));\\n}\\n\\nvec3 blendLighten(vec3 base, vec3 blend, float opacity) {\\n\\treturn (blendLighten(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n// Linear burn\\n\\nfloat blendLinearBurn(float base, float blend) {\\n\\t// Note : Same implementation as BlendSubtractf\\n\\treturn max(base+blend-1.0,0.0);\\n}\\n\\nvec3 blendLinearBurn(vec3 base, vec3 blend) {\\n\\t// Note : Same implementation as BlendSubtract\\n\\treturn max(base+blend-vec3(1.0),vec3(0.0));\\n}\\n\\nvec3 blendLinearBurn(vec3 base, vec3 blend, float opacity) {\\n\\treturn (blendLinearBurn(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n// Linear dodge\\n\\nfloat blendLinearDodge(float base, float blend) {\\n\\t// Note : Same implementation as BlendAddf\\n\\treturn min(base+blend,1.0);\\n}\\n\\nvec3 blendLinearDodge(vec3 base, vec3 blend) {\\n\\t// Note : Same implementation as BlendAdd\\n\\treturn min(base+blend,vec3(1.0));\\n}\\n\\nvec3 blendLinearDodge(vec3 base, vec3 blend, float opacity) {\\n\\treturn (blendLinearDodge(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n// Linear light\\n\\nfloat blendLinearLight(float base, float blend) {\\n\\treturn blend<0.5?blendLinearBurn(base,(2.0*blend)):blendLinearDodge(base,(2.0*(blend-0.5)));\\n}\\n\\nvec3 blendLinearLight(vec3 base, vec3 blend) {\\n\\treturn vec3(blendLinearLight(base.r,blend.r),blendLinearLight(base.g,blend.g),blendLinearLight(base.b,blend.b));\\n}\\n\\nvec3 blendLinearLight(vec3 base, vec3 blend, float opacity) {\\n\\treturn (blendLinearLight(base, blend) * opacity + base * (1.0 - opacity));\\n}\",\n      fragment: \"varying vec3 v_color;\\n\\nvoid main() {\\n  vec3 color = v_color;\\n  if (u_darken_top == 1.0) {\\n    vec2 st = gl_FragCoord.xy/resolution.xy;\\n    color.g -= pow(st.y + sin(-12.0) * st.x, u_shadow_power) * 0.4;\\n  }\\n  gl_FragColor = vec4(color, 1.0);\\n}\"\n    }, this.conf = {\n      presetName: \"\",\n      wireframe: false,\n      density: [.06, .16],\n      zoom: 1,\n      rotation: 0,\n      playing: true\n    }, document.querySelectorAll(\"canvas\").length < 1 ? console.log(\"DID NOT LOAD HERO STRIPE CANVAS\") : (this.minigl = new MiniGl(this.el, null, null, !0), requestAnimationFrame(() => {\n      this.el && (this.computedCanvasStyle = getComputedStyle(this.el), this.waitForCssVars());\n    })\n    /*\n    this.scrollObserver = await s.create(.1, !1),\n    this.scrollObserver.observe(this.el),\n    this.scrollObserver.onSeparate(() => {\n        window.removeEventListener(\"scroll\", this.handleScroll), window.removeEventListener(\"mousedown\", this.handleMouseDown), window.removeEventListener(\"mouseup\", this.handleMouseUp), window.removeEventListener(\"keydown\", this.handleKeyDown), this.isIntersecting = !1, this.conf.playing && this.pause()\n    }), \n    this.scrollObserver.onIntersect(() => {\n        window.addEventListener(\"scroll\", this.handleScroll), window.addEventListener(\"mousedown\", this.handleMouseDown), window.addEventListener(\"mouseup\", this.handleMouseUp), window.addEventListener(\"keydown\", this.handleKeyDown), this.isIntersecting = !0, this.addIsLoadedClass(), this.play()\n    })*/);\n  }\n\n  disconnect() {\n    this.scrollObserver && (window.removeEventListener(\"scroll\", this.handleScroll), window.removeEventListener(\"mousedown\", this.handleMouseDown), window.removeEventListener(\"mouseup\", this.handleMouseUp), window.removeEventListener(\"keydown\", this.handleKeyDown), this.scrollObserver.disconnect()), window.removeEventListener(\"resize\", this.resize);\n  }\n  initMaterial() {\n    this.uniforms = {\n      u_time: new this.minigl.Uniform({\n        value: 0\n      }),\n      u_shadow_power: new this.minigl.Uniform({\n        value: 5\n      }),\n      u_darken_top: new this.minigl.Uniform({\n        value: \"\" === this.el.dataset.jsDarkenTop ? 1 : 0\n      }),\n      u_active_colors: new this.minigl.Uniform({\n        value: this.activeColors,\n        type: \"vec4\"\n      }),\n      u_global: new this.minigl.Uniform({\n        value: {\n          noiseFreq: new this.minigl.Uniform({\n            value: [this.freqX, this.freqY],\n            type: \"vec2\"\n          }),\n          noiseSpeed: new this.minigl.Uniform({\n            value: 5e-6\n          })\n        },\n        type: \"struct\"\n      }),\n      u_vertDeform: new this.minigl.Uniform({\n        value: {\n          incline: new this.minigl.Uniform({\n            value: Math.sin(this.angle) / Math.cos(this.angle)\n          }),\n          offsetTop: new this.minigl.Uniform({\n            value: -.5\n          }),\n          offsetBottom: new this.minigl.Uniform({\n            value: -.5\n          }),\n          noiseFreq: new this.minigl.Uniform({\n            value: [3, 4],\n            type: \"vec2\"\n          }),\n          noiseAmp: new this.minigl.Uniform({\n            value: this.amp\n          }),\n          noiseSpeed: new this.minigl.Uniform({\n            value: 10\n          }),\n          noiseFlow: new this.minigl.Uniform({\n            value: 3\n          }),\n          noiseSeed: new this.minigl.Uniform({\n            value: this.seed\n          })\n        },\n        type: \"struct\",\n        excludeFrom: \"fragment\"\n      }),\n      u_baseColor: new this.minigl.Uniform({\n        value: this.sectionColors[0],\n        type: \"vec3\",\n        excludeFrom: \"fragment\"\n      }),\n      u_waveLayers: new this.minigl.Uniform({\n        value: [],\n        excludeFrom: \"fragment\",\n        type: \"array\"\n      })\n    };\n    for (let e = 1; e < this.sectionColors.length; e += 1) this.uniforms.u_waveLayers.value.push(new this.minigl.Uniform({\n      value: {\n        color: new this.minigl.Uniform({\n          value: this.sectionColors[e],\n          type: \"vec3\"\n        }),\n        noiseFreq: new this.minigl.Uniform({\n          value: [2 + e / this.sectionColors.length, 3 + e / this.sectionColors.length],\n          type: \"vec2\"\n        }),\n        noiseSpeed: new this.minigl.Uniform({\n          value: 11 + .3 * e\n        }),\n        noiseFlow: new this.minigl.Uniform({\n          value: 6.5 + .3 * e\n        }),\n        noiseSeed: new this.minigl.Uniform({\n          value: this.seed + 10 * e\n        }),\n        noiseFloor: new this.minigl.Uniform({\n          value: .1\n        }),\n        noiseCeil: new this.minigl.Uniform({\n          value: .63 + .07 * e\n        })\n      },\n      type: \"struct\"\n    }));\n    return this.vertexShader = [this.shaderFiles.noise, this.shaderFiles.blend, this.shaderFiles.vertex].join(\"\\n\\n\"), new this.minigl.Material(this.vertexShader, this.shaderFiles.fragment, this.uniforms);\n  }\n  initMesh() {\n    this.material = this.initMaterial(), this.geometry = new this.minigl.PlaneGeometry(), this.mesh = new this.minigl.Mesh(this.geometry, this.material);\n  }\n  shouldSkipFrame(e) {\n    return !!window.document.hidden || !this.conf.playing || parseInt(e, 10) % 2 == 0 || void 0;\n  }\n  updateFrequency(e) {\n    this.freqX += e, this.freqY += e;\n  }\n  toggleColor(index) {\n    this.activeColors[index] = 0 === this.activeColors[index] ? 1 : 0;\n  }\n  showGradientLegend() {\n    this.width > this.minWidth && (this.isGradientLegendVisible = !0, document.body.classList.add(\"isGradientLegendVisible\"));\n  }\n  hideGradientLegend() {\n    this.isGradientLegendVisible = !1, document.body.classList.remove(\"isGradientLegendVisible\");\n  }\n  init() {\n    this.initGradientColors(), this.initMesh(), this.resize(), requestAnimationFrame(this.animate), window.addEventListener(\"resize\", this.resize);\n  }\n  /*\n  * Waiting for the css variables to become available, usually on page load before we can continue.\n  * Using default colors assigned below if no variables have been found after maxCssVarRetries\n  */\n  waitForCssVars() {\n    if (this.computedCanvasStyle && -1 !== this.computedCanvasStyle.getPropertyValue(\"--gradient-color-1\").indexOf(\"#\")) this.init(), this.addIsLoadedClass();else {\n      if (this.cssVarRetries += 1, this.cssVarRetries > this.maxCssVarRetries) {\n        return this.sectionColors = [16711680, 16711680, 16711935, 65280, 255], void this.init();\n      }\n      requestAnimationFrame(() => this.waitForCssVars());\n    }\n  }\n  /*\n  * Initializes the four section colors by retrieving them from css variables.\n  */\n  initGradientColors() {\n    this.sectionColors = [\"--gradient-color-1\", \"--gradient-color-2\", \"--gradient-color-3\", \"--gradient-color-4\"].map(cssPropertyName => {\n      let hex = this.computedCanvasStyle.getPropertyValue(cssPropertyName).trim();\n      //Check if shorthand hex value was used and double the length so the conversion in normalizeColor will work.\n      if (4 === hex.length) {\n        const hexTemp = hex.substr(1).split(\"\").map(hexTemp => hexTemp + hexTemp).join(\"\");\n        hex = `#${hexTemp}`;\n      }\n      return hex && `0x${hex.substr(1)}`;\n    }).filter(Boolean).map(normalizeColor);\n  }\n}\n\n/*\n*Finally initializing the Gradient class, assigning a canvas to it and calling Gradient.connect() which initializes everything,\n* Use Gradient.pause() and Gradient.play() for controls.\n*\n* Here are some default property values you can change anytime:\n* Amplitude:    Gradient.amp = 0\n* Colors:       Gradient.sectionColors (if you change colors, use normalizeColor(#hexValue)) before you assign it.\n*\n*\n* Useful functions\n* Gradient.toggleColor(index)\n* Gradient.updateFrequency(freq)\n*/\nvar gradient = new Gradient();\ngradient.initGradient(\"#gradient-canvas\");","map":{"version":3,"names":["console","log","normalizeColor","hexCode","reduce","t","n","Object","assign","MiniGl","constructor","canvas","width","height","debug","arguments","length","undefined","_miniGl","debug_output","document","location","search","toLowerCase","indexOf","gl","getContext","antialias","meshes","context","setSize","lastDebugMsg","e","Date","toLocaleTimeString","Array","Math","max","join","from","slice","defineProperties","Material","enumerable","value","vertexShaders","fragments","uniforms","material","getShaderByType","type","source","shader","createShader","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","error","getShaderInfoLog","getUniformVariableDeclarations","entries","map","_ref","uniform","getDeclaration","uniformInstances","prefix","vertexSource","commonUniforms","Source","vertexShader","VERTEX_SHADER","fragmentShader","FRAGMENT_SHADER","program","createProgram","attachShader","linkProgram","getProgramParameter","LINK_STATUS","getProgramInfoLog","useProgram","attachUniforms","name","forEach","_ref2","i","_ref3","push","getUniformLocation","Uniform","typeFn","float","int","vec2","vec3","vec4","mat4","update","transpose","excludeFrom","name_no_prefix","replace","charAt","toUpperCase","_ref4","PlaneGeometry","orientation","createBuffer","attributes","position","Attribute","target","ARRAY_BUFFER","size","uv","uvNorm","index","ELEMENT_ARRAY_BUFFER","UNSIGNED_SHORT","setTopology","xSegCount","ySegCount","vertexCount","quadCount","values","Float32Array","Uint16Array","s","geometry","o","r","segment_width","segment_height","yIndex","xIndex","l","Mesh","mesh","wireframe","attributeInstances","_ref5","attribute","attach","draw","_ref6","_ref7","use","drawElements","LINES","TRIANGLES","remove","filter","FLOAT","normalized","buffer","bindBuffer","bufferData","STATIC_DRAW","getAttribLocation","enableVertexAttribArray","vertexAttribPointer","a","projectionMatrix","modelViewMatrix","resolution","aspectRatio","viewport","setOrthographicCamera","render","clearColor","clearDepth","object","propertyName","val","defineProperty","configurable","writable","Gradient","clearTimeout","scrollingTimeout","setTimeout","handleScrollEnd","scrollingRefreshDelay","isGradientLegendVisible","hideGradientLegend","conf","playing","isScrolling","pause","isIntersecting","play","window","innerWidth","minigl","ceil","density","u_shadow_power","isMetaKey","metaKey","isMouseDown","requestAnimationFrame","animate","shouldSkipFrame","min","last","u_time","isStatic","disconnect","isLoadedClass","el","classList","add","parentElement","selector","querySelector","connect","shaderFiles","vertex","noise","blend","fragment","presetName","zoom","rotation","querySelectorAll","computedCanvasStyle","getComputedStyle","waitForCssVars","scrollObserver","removeEventListener","handleScroll","handleMouseDown","handleMouseUp","handleKeyDown","resize","initMaterial","u_darken_top","dataset","jsDarkenTop","u_active_colors","activeColors","u_global","noiseFreq","freqX","freqY","noiseSpeed","u_vertDeform","incline","sin","angle","cos","offsetTop","offsetBottom","noiseAmp","amp","noiseFlow","noiseSeed","seed","u_baseColor","sectionColors","u_waveLayers","color","noiseFloor","noiseCeil","initMesh","hidden","parseInt","updateFrequency","toggleColor","showGradientLegend","minWidth","body","init","initGradientColors","addEventListener","getPropertyValue","addIsLoadedClass","cssVarRetries","maxCssVarRetries","cssPropertyName","hex","trim","hexTemp","substr","split","Boolean","gradient","initGradient"],"sources":["/Users/charlesbuckley/coding/uniswap-v3-subgraph/src/components/Gradient.js"],"sourcesContent":["console.log('hello')\n/* eslint-disable no-unused-expressions */\n/* eslint-disable no-sequences */\n//Converting colors to proper format\nfunction normalizeColor(hexCode) {\n  return [(hexCode >> 16 & 255) / 255, (hexCode >> 8 & 255) / 255, (255 & hexCode) / 255]\n} [\"SCREEN\", \"LINEAR_LIGHT\"].reduce((hexCode, t, n) => Object.assign(hexCode, {\n  [t]: n\n}), {});\n\n//Essential functionality of WebGl\n//t = width\n//n = height\nclass MiniGl {\n  constructor(canvas, width, height, debug = false) {\n      const _miniGl = this,\n          debug_output = -1 !== document.location.search.toLowerCase().indexOf(\"debug=webgl\");\n      _miniGl.canvas = canvas, _miniGl.gl = _miniGl.canvas.getContext(\"webgl\", {\n          antialias: true\n      }), _miniGl.meshes = [];\n      const context = _miniGl.gl;\n      width && height && this.setSize(width, height), _miniGl.lastDebugMsg, _miniGl.debug = debug && debug_output ? function(e) {\n          const t = new Date;\n          t - _miniGl.lastDebugMsg > 1e3 && console.log(\"---\"), console.log(t.toLocaleTimeString() + Array(Math.max(0, 32 - e.length)).join(\" \") + e + \": \", ...Array.from(arguments).slice(1)), _miniGl.lastDebugMsg = t\n      } : () => {}, Object.defineProperties(_miniGl, {\n          Material: {\n              enumerable: false,\n              value: class {\n                  constructor(vertexShaders, fragments, uniforms = {}) {\n                      const material = this;\n                      function getShaderByType(type, source) {\n                          const shader = context.createShader(type);\n                          return context.shaderSource(shader, source), context.compileShader(shader), context.getShaderParameter(shader, context.COMPILE_STATUS) || console.error(context.getShaderInfoLog(shader)), _miniGl.debug(\"Material.compileShaderSource\", {\n                              source: source\n                          }), shader\n                      }\n                      function getUniformVariableDeclarations(uniforms, type) {\n                          return Object.entries(uniforms).map(([uniform, value]) => value.getDeclaration(uniform, type)).join(\"\\n\")\n                      }\n                      material.uniforms = uniforms, material.uniformInstances = [];\n\n                      const prefix = \"\\n              precision highp float;\\n            \";\n                      material.vertexSource = `\\n              ${prefix}\\n              attribute vec4 position;\\n              attribute vec2 uv;\\n              attribute vec2 uvNorm;\\n              ${getUniformVariableDeclarations(_miniGl.commonUniforms,\"vertex\")}\\n              ${getUniformVariableDeclarations(uniforms,\"vertex\")}\\n              ${vertexShaders}\\n            `,\n                      material.Source = `\\n              ${prefix}\\n              ${getUniformVariableDeclarations(_miniGl.commonUniforms,\"fragment\")}\\n              ${getUniformVariableDeclarations(uniforms,\"fragment\")}\\n              ${fragments}\\n            `,\n                      material.vertexShader = getShaderByType(context.VERTEX_SHADER, material.vertexSource),\n                      material.fragmentShader = getShaderByType(context.FRAGMENT_SHADER, material.Source),\n                      material.program = context.createProgram(),\n                      context.attachShader(material.program, material.vertexShader),\n                      context.attachShader(material.program, material.fragmentShader),\n                      context.linkProgram(material.program),\n                      context.getProgramParameter(material.program, context.LINK_STATUS) || console.error(context.getProgramInfoLog(material.program)),\n                      context.useProgram(material.program),\n                      material.attachUniforms(void 0, _miniGl.commonUniforms),\n                      material.attachUniforms(void 0, material.uniforms)\n                  }\n                  //t = uniform\n                  attachUniforms(name, uniforms) {\n                      //n  = material\n                      const material = this;\n                      void 0 === name ? Object.entries(uniforms).forEach(([name, uniform]) => {\n                          material.attachUniforms(name, uniform)\n                      }) : \"array\" == uniforms.type ? uniforms.value.forEach((uniform, i) => material.attachUniforms(`${name}[${i}]`, uniform)) : \"struct\" == uniforms.type ? Object.entries(uniforms.value).forEach(([uniform, i]) => material.attachUniforms(`${name}.${uniform}`, i)) : (_miniGl.debug(\"Material.attachUniforms\", {\n                          name: name,\n                          uniform: uniforms\n                      }), material.uniformInstances.push({\n                          uniform: uniforms,\n                          location: context.getUniformLocation(material.program, name)\n                      }))\n                  }\n              }\n          },\n          Uniform: {\n              enumerable: !1,\n              value: class {\n                  constructor(e) {\n                      this.type = \"float\", Object.assign(this, e);\n                      this.typeFn = {\n                          float: \"1f\",\n                          int: \"1i\",\n                          vec2: \"2fv\",\n                          vec3: \"3fv\",\n                          vec4: \"4fv\",\n                          mat4: \"Matrix4fv\"\n                      } [this.type] || \"1f\", this.update()\n                  }\n                  update(value) {\n                      void 0 !== this.value && context[`uniform${this.typeFn}`](value, 0 === this.typeFn.indexOf(\"Matrix\") ? this.transpose : this.value, 0 === this.typeFn.indexOf(\"Matrix\") ? this.value : null)\n                  }\n                  //e - name\n                  //t - type\n                  //n - length\n                  getDeclaration(name, type, length) {\n                      const uniform = this;\n                      if (uniform.excludeFrom !== type) {\n                          if (\"array\" === uniform.type) return uniform.value[0].getDeclaration(name, type, uniform.value.length) + `\\nconst int ${name}_length = ${uniform.value.length};`;\n                          if (\"struct\" === uniform.type) {\n                              let name_no_prefix = name.replace(\"u_\", \"\");\n                              return name_no_prefix = \n                                name_no_prefix.charAt(0).toUpperCase() + \n                                name_no_prefix.slice(1), \n                                `uniform struct ${name_no_prefix} \n                                {\\n` + \n                                Object.entries(uniform.value).map(([name, uniform]) => \n                                uniform.getDeclaration(name, type)\n                                .replace(/^uniform/, \"\"))\n                                .join(\"\") \n                                + `\\n} ${name}${length>0?`[${length}]`:\"\"};`\n                          }\n                          return `uniform ${uniform.type} ${name}${length>0?`[${length}]`:\"\"};`\n                      }\n                  }\n              }\n          },\n          PlaneGeometry: {\n              enumerable: !1,\n              value: class {\n                  constructor(width, height, n, i, orientation) {\n                    context.createBuffer(), this.attributes = {\n                          position: new _miniGl.Attribute({\n                              target: context.ARRAY_BUFFER,\n                              size: 3\n                          }),\n                          uv: new _miniGl.Attribute({\n                              target: context.ARRAY_BUFFER,\n                              size: 2\n                          }),\n                          uvNorm: new _miniGl.Attribute({\n                              target: context.ARRAY_BUFFER,\n                              size: 2\n                          }),\n                          index: new _miniGl.Attribute({\n                              target: context.ELEMENT_ARRAY_BUFFER,\n                              size: 3,\n                              type: context.UNSIGNED_SHORT\n                          })\n                      }, this.setTopology(n, i), this.setSize(width, height, orientation)\n                  }\n                  setTopology(e = 1, t = 1) {\n                      const n = this;\n                      n.xSegCount = e, n.ySegCount = t, n.vertexCount = (n.xSegCount + 1) * (n.ySegCount + 1), n.quadCount = n.xSegCount * n.ySegCount * 2, n.attributes.uv.values = new Float32Array(2 * n.vertexCount), n.attributes.uvNorm.values = new Float32Array(2 * n.vertexCount), n.attributes.index.values = new Uint16Array(3 * n.quadCount);\n                      for (let e = 0; e <= n.ySegCount; e++)\n                          for (let t = 0; t <= n.xSegCount; t++) {\n                              const i = e * (n.xSegCount + 1) + t;\n                              if (n.attributes.uv.values[2 * i] = t / n.xSegCount, n.attributes.uv.values[2 * i + 1] = 1 - e / n.ySegCount, n.attributes.uvNorm.values[2 * i] = t / n.xSegCount * 2 - 1, n.attributes.uvNorm.values[2 * i + 1] = 1 - e / n.ySegCount * 2, t < n.xSegCount && e < n.ySegCount) {\n                                  const s = e * n.xSegCount + t;\n                                  n.attributes.index.values[6 * s] = i, n.attributes.index.values[6 * s + 1] = i + 1 + n.xSegCount, n.attributes.index.values[6 * s + 2] = i + 1, n.attributes.index.values[6 * s + 3] = i + 1, n.attributes.index.values[6 * s + 4] = i + 1 + n.xSegCount, n.attributes.index.values[6 * s + 5] = i + 2 + n.xSegCount\n                              }\n                          }\n                      n.attributes.uv.update(), n.attributes.uvNorm.update(), n.attributes.index.update(), _miniGl.debug(\"Geometry.setTopology\", {\n                          uv: n.attributes.uv,\n                          uvNorm: n.attributes.uvNorm,\n                          index: n.attributes.index\n                      })\n                  }\n                  setSize(width = 1, height = 1, orientation = \"xz\") {\n                      const geometry = this;\n                      geometry.width = width,\n                      geometry.height = height,\n                      geometry.orientation = orientation,\n                      geometry.attributes.position.values && geometry.attributes.position.values.length === 3 * geometry.vertexCount \n                      || (geometry.attributes.position.values = new Float32Array(3 * geometry.vertexCount));\n                      const o = width / -2,\n                          r = height / -2,\n                          segment_width = width / geometry.xSegCount,\n                          segment_height = height / geometry.ySegCount;\n                      for (let yIndex= 0; yIndex <= geometry.ySegCount; yIndex++) {\n                          const t = r + yIndex * segment_height;\n                          for (let xIndex = 0; xIndex <= geometry.xSegCount; xIndex++) {\n                              const r = o + xIndex * segment_width,\n                                  l = yIndex * (geometry.xSegCount + 1) + xIndex;\n                              geometry.attributes.position.values[3 * l + \"xyz\".indexOf(orientation[0])] = r, \n                              geometry.attributes.position.values[3 * l + \"xyz\".indexOf(orientation[1])] = -t\n                          }\n                      }\n                      geometry.attributes.position.update(), _miniGl.debug(\"Geometry.setSize\", {\n                          position: geometry.attributes.position\n                      })\n                  }\n              }\n          },\n          Mesh: {\n              enumerable: !1,\n              value: class {\n                  constructor(geometry, material) {\n                      const mesh = this;\n                      mesh.geometry = geometry, mesh.material = material, mesh.wireframe = !1, mesh.attributeInstances = [], Object.entries(mesh.geometry.attributes).forEach(([e, attribute]) => {\n                          mesh.attributeInstances.push({\n                              attribute: attribute,\n                              location: attribute.attach(e, mesh.material.program)\n                          })\n                      }), _miniGl.meshes.push(mesh), _miniGl.debug(\"Mesh.constructor\", {\n                          mesh: mesh\n                      })\n                  }\n                  draw() {\n                    context.useProgram(this.material.program), this.material.uniformInstances.forEach(({\n                          uniform: e,\n                          location: t\n                      }) => e.update(t)), this.attributeInstances.forEach(({\n                          attribute: e,\n                          location: t\n                      }) => e.use(t)), context.drawElements(this.wireframe ? context.LINES : context.TRIANGLES, this.geometry.attributes.index.values.length, context.UNSIGNED_SHORT, 0)\n                  }\n                  remove() {\n                      _miniGl.meshes = _miniGl.meshes.filter(e => e != this)\n                  }\n              }\n          },\n          Attribute: {\n              enumerable: !1,\n              value: class {\n                  constructor(e) {\n                      this.type = context.FLOAT, this.normalized = !1, this.buffer = context.createBuffer(), Object.assign(this, e), this.update()\n                  }\n                  update() {\n                      void 0 !== this.values && (context.bindBuffer(this.target, this.buffer), context.bufferData(this.target, this.values, context.STATIC_DRAW))\n                  }\n                  attach(e, t) {\n                      const n = context.getAttribLocation(t, e);\n                      return this.target === context.ARRAY_BUFFER && (context.enableVertexAttribArray(n), context.vertexAttribPointer(n, this.size, this.type, this.normalized, 0, 0)), n\n                  }\n                  use(e) {\n                    context.bindBuffer(this.target, this.buffer), this.target === context.ARRAY_BUFFER && (context.enableVertexAttribArray(e), context.vertexAttribPointer(e, this.size, this.type, this.normalized, 0, 0))\n                  }\n              }\n          }\n      });\n      const a = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\n      _miniGl.commonUniforms = {\n          projectionMatrix: new _miniGl.Uniform({\n              type: \"mat4\",\n              value: a\n          }),\n          modelViewMatrix: new _miniGl.Uniform({\n              type: \"mat4\",\n              value: a\n          }),\n          resolution: new _miniGl.Uniform({\n              type: \"vec2\",\n              value: [1, 1]\n          }),\n          aspectRatio: new _miniGl.Uniform({\n              type: \"float\",\n              value: 1\n          })\n      }\n  }\n  setSize(e = 640, t = 480) {\n      this.width = e, this.height = t, this.canvas.width = e, this.canvas.height = t, this.gl.viewport(0, 0, e, t), this.commonUniforms.resolution.value = [e, t], this.commonUniforms.aspectRatio.value = e / t, this.debug(\"MiniGL.setSize\", {\n          width: e,\n          height: t\n      })\n  }\n  //left, right, top, bottom, near, far\n  setOrthographicCamera(e = 0, t = 0, n = 0, i = -2e3, s = 2e3) {\n      this.commonUniforms.projectionMatrix.value = [2 / this.width, 0, 0, 0, 0, 2 / this.height, 0, 0, 0, 0, 2 / (i - s), 0, e, t, n, 1], this.debug(\"setOrthographicCamera\", this.commonUniforms.projectionMatrix.value)\n  }\n  render() {\n      this.gl.clearColor(0, 0, 0, 0), this.gl.clearDepth(1), this.meshes.forEach(e => e.draw())\n  }\n}\n\n\n\n//Sets initial properties\nfunction e(object, propertyName, val) {\n  return propertyName in object ? Object.defineProperty(object, propertyName, {\n      value: val,\n      enumerable: !0,\n      configurable: !0,\n      writable: !0\n  }) : object[propertyName] = val, object\n}\n\n//Gradient object\nclass Gradient {\n  constructor(...t) {\n      e(this, \"el\", void 0), e(this, \"cssVarRetries\", 0), e(this, \"maxCssVarRetries\", 200), e(this, \"angle\", 0), e(this, \"isLoadedClass\", !1), e(this, \"isScrolling\", !1), /*e(this, \"isStatic\", o.disableAmbientAnimations()),*/ e(this, \"scrollingTimeout\", void 0), e(this, \"scrollingRefreshDelay\", 200), e(this, \"isIntersecting\", !1), e(this, \"shaderFiles\", void 0), e(this, \"vertexShader\", void 0), e(this, \"sectionColors\", void 0), e(this, \"computedCanvasStyle\", void 0), e(this, \"conf\", void 0), e(this, \"uniforms\", void 0), e(this, \"t\", 1253106), e(this, \"last\", 0), e(this, \"width\", void 0), e(this, \"minWidth\", 1111), e(this, \"height\", 600), e(this, \"xSegCount\", void 0), e(this, \"ySegCount\", void 0), e(this, \"mesh\", void 0), e(this, \"material\", void 0), e(this, \"geometry\", void 0), e(this, \"minigl\", void 0), e(this, \"scrollObserver\", void 0), e(this, \"amp\", 320), e(this, \"seed\", 5), e(this, \"freqX\", 14e-5), e(this, \"freqY\", 29e-5), e(this, \"freqDelta\", 1e-5), e(this, \"activeColors\", [1, 1, 1, 1]), e(this, \"isMetaKey\", !1), e(this, \"isGradientLegendVisible\", !1), e(this, \"isMouseDown\", !1), e(this, \"handleScroll\", () => {\n          clearTimeout(this.scrollingTimeout), this.scrollingTimeout = setTimeout(this.handleScrollEnd, this.scrollingRefreshDelay), this.isGradientLegendVisible && this.hideGradientLegend(), this.conf.playing && (this.isScrolling = !0, this.pause())\n      }), e(this, \"handleScrollEnd\", () => {\n          this.isScrolling = !1, this.isIntersecting && this.play()\n      }), e(this, \"resize\", () => {\n          this.width = window.innerWidth, this.minigl.setSize(this.width, this.height), this.minigl.setOrthographicCamera(), this.xSegCount = Math.ceil(this.width * this.conf.density[0]), this.ySegCount = Math.ceil(this.height * this.conf.density[1]), this.mesh.geometry.setTopology(this.xSegCount, this.ySegCount), this.mesh.geometry.setSize(this.width, this.height), this.mesh.material.uniforms.u_shadow_power.value = this.width < 600 ? 5 : 6\n      }), e(this, \"handleMouseDown\", e => {\n          this.isGradientLegendVisible && (this.isMetaKey = e.metaKey, this.isMouseDown = !0, !1 === this.conf.playing && requestAnimationFrame(this.animate))\n      }), e(this, \"handleMouseUp\", () => {\n          this.isMouseDown = !1\n      }), e(this, \"animate\", e => {\n          if (!this.shouldSkipFrame(e) || this.isMouseDown) {\n              if (this.t += Math.min(e - this.last, 1e3 / 15), this.last = e, this.isMouseDown) {\n                  let e = 160;\n                  this.isMetaKey && (e = -160), this.t += e\n              }\n              this.mesh.material.uniforms.u_time.value = this.t, this.minigl.render()\n\n          }\n          if (0 !== this.last && this.isStatic) return this.minigl.render(), void this.disconnect();\n          (/*this.isIntersecting && */this.conf.playing || this.isMouseDown) && requestAnimationFrame(this.animate)\n      }), e(this, \"addIsLoadedClass\", () => {\n          /*this.isIntersecting && */!this.isLoadedClass && (this.isLoadedClass = !0, this.el.classList.add(\"isLoaded\"), setTimeout(() => {\n              this.el.parentElement.classList.add(\"isLoaded\")\n          }, 3e3))\n      }), e(this, \"pause\", () => {\n          this.conf.playing = false\n      }), e(this, \"play\", () => {\n          requestAnimationFrame(this.animate), this.conf.playing = true\n      }), e(this,\"initGradient\", (selector) => {\n        this.el = document.querySelector(selector);\n        this.connect();\n        return this;\n      })\n  }\n  async connect() {\n      this.shaderFiles = {\n          vertex: \"varying vec3 v_color;\\n\\nvoid main() {\\n  float time = u_time * u_global.noiseSpeed;\\n\\n  vec2 noiseCoord = resolution * uvNorm * u_global.noiseFreq;\\n\\n  vec2 st = 1. - uvNorm.xy;\\n\\n  //\\n  // Tilting the plane\\n  //\\n\\n  // Front-to-back tilt\\n  float tilt = resolution.y / 2.0 * uvNorm.y;\\n\\n  // Left-to-right angle\\n  float incline = resolution.x * uvNorm.x / 2.0 * u_vertDeform.incline;\\n\\n  // Up-down shift to offset incline\\n  float offset = resolution.x / 2.0 * u_vertDeform.incline * mix(u_vertDeform.offsetBottom, u_vertDeform.offsetTop, uv.y);\\n\\n  //\\n  // Vertex noise\\n  //\\n\\n  float noise = snoise(vec3(\\n    noiseCoord.x * u_vertDeform.noiseFreq.x + time * u_vertDeform.noiseFlow,\\n    noiseCoord.y * u_vertDeform.noiseFreq.y,\\n    time * u_vertDeform.noiseSpeed + u_vertDeform.noiseSeed\\n  )) * u_vertDeform.noiseAmp;\\n\\n  // Fade noise to zero at edges\\n  noise *= 1.0 - pow(abs(uvNorm.y), 2.0);\\n\\n  // Clamp to 0\\n  noise = max(0.0, noise);\\n\\n  vec3 pos = vec3(\\n    position.x,\\n    position.y + tilt + incline + noise - offset,\\n    position.z\\n  );\\n\\n  //\\n  // Vertex color, to be passed to fragment shader\\n  //\\n\\n  if (u_active_colors[0] == 1.) {\\n    v_color = u_baseColor;\\n  }\\n\\n  for (int i = 0; i < u_waveLayers_length; i++) {\\n    if (u_active_colors[i + 1] == 1.) {\\n      WaveLayers layer = u_waveLayers[i];\\n\\n      float noise = smoothstep(\\n        layer.noiseFloor,\\n        layer.noiseCeil,\\n        snoise(vec3(\\n          noiseCoord.x * layer.noiseFreq.x + time * layer.noiseFlow,\\n          noiseCoord.y * layer.noiseFreq.y,\\n          time * layer.noiseSpeed + layer.noiseSeed\\n        )) / 2.0 + 0.5\\n      );\\n\\n      v_color = blendNormal(v_color, layer.color, pow(noise, 4.));\\n    }\\n  }\\n\\n  //\\n  // Finish\\n  //\\n\\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\\n}\",\n          noise: \"//\\n// Description : Array and textureless GLSL 2D/3D/4D simplex\\n//               noise functions.\\n//      Author : Ian McEwan, Ashima Arts.\\n//  Maintainer : stegu\\n//     Lastmod : 20110822 (ijm)\\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\\n//               Distributed under the MIT License. See LICENSE file.\\n//               https://github.com/ashima/webgl-noise\\n//               https://github.com/stegu/webgl-noise\\n//\\n\\nvec3 mod289(vec3 x) {\\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\\n}\\n\\nvec4 mod289(vec4 x) {\\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\\n}\\n\\nvec4 permute(vec4 x) {\\n    return mod289(((x*34.0)+1.0)*x);\\n}\\n\\nvec4 taylorInvSqrt(vec4 r)\\n{\\n  return 1.79284291400159 - 0.85373472095314 * r;\\n}\\n\\nfloat snoise(vec3 v)\\n{\\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\\n\\n// First corner\\n  vec3 i  = floor(v + dot(v, C.yyy) );\\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\\n\\n// Other corners\\n  vec3 g = step(x0.yzx, x0.xyz);\\n  vec3 l = 1.0 - g;\\n  vec3 i1 = min( g.xyz, l.zxy );\\n  vec3 i2 = max( g.xyz, l.zxy );\\n\\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\\n  vec3 x1 = x0 - i1 + C.xxx;\\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\\n\\n// Permutations\\n  i = mod289(i);\\n  vec4 p = permute( permute( permute(\\n            i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\\n          + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\\n          + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\\n\\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\\n  float n_ = 0.142857142857; // 1.0/7.0\\n  vec3  ns = n_ * D.wyz - D.xzx;\\n\\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\\n\\n  vec4 x_ = floor(j * ns.z);\\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\\n\\n  vec4 x = x_ *ns.x + ns.yyyy;\\n  vec4 y = y_ *ns.x + ns.yyyy;\\n  vec4 h = 1.0 - abs(x) - abs(y);\\n\\n  vec4 b0 = vec4( x.xy, y.xy );\\n  vec4 b1 = vec4( x.zw, y.zw );\\n\\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\\n  vec4 s0 = floor(b0)*2.0 + 1.0;\\n  vec4 s1 = floor(b1)*2.0 + 1.0;\\n  vec4 sh = -step(h, vec4(0.0));\\n\\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\\n\\n  vec3 p0 = vec3(a0.xy,h.x);\\n  vec3 p1 = vec3(a0.zw,h.y);\\n  vec3 p2 = vec3(a1.xy,h.z);\\n  vec3 p3 = vec3(a1.zw,h.w);\\n\\n//Normalise gradients\\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\\n  p0 *= norm.x;\\n  p1 *= norm.y;\\n  p2 *= norm.z;\\n  p3 *= norm.w;\\n\\n// Mix final noise value\\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\\n  m = m * m;\\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\\n                                dot(p2,x2), dot(p3,x3) ) );\\n}\",\n          blend: \"//\\n// https://github.com/jamieowen/glsl-blend\\n//\\n\\n// Normal\\n\\nvec3 blendNormal(vec3 base, vec3 blend) {\\n\\treturn blend;\\n}\\n\\nvec3 blendNormal(vec3 base, vec3 blend, float opacity) {\\n\\treturn (blendNormal(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n// Screen\\n\\nfloat blendScreen(float base, float blend) {\\n\\treturn 1.0-((1.0-base)*(1.0-blend));\\n}\\n\\nvec3 blendScreen(vec3 base, vec3 blend) {\\n\\treturn vec3(blendScreen(base.r,blend.r),blendScreen(base.g,blend.g),blendScreen(base.b,blend.b));\\n}\\n\\nvec3 blendScreen(vec3 base, vec3 blend, float opacity) {\\n\\treturn (blendScreen(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n// Multiply\\n\\nvec3 blendMultiply(vec3 base, vec3 blend) {\\n\\treturn base*blend;\\n}\\n\\nvec3 blendMultiply(vec3 base, vec3 blend, float opacity) {\\n\\treturn (blendMultiply(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n// Overlay\\n\\nfloat blendOverlay(float base, float blend) {\\n\\treturn base<0.5?(2.0*base*blend):(1.0-2.0*(1.0-base)*(1.0-blend));\\n}\\n\\nvec3 blendOverlay(vec3 base, vec3 blend) {\\n\\treturn vec3(blendOverlay(base.r,blend.r),blendOverlay(base.g,blend.g),blendOverlay(base.b,blend.b));\\n}\\n\\nvec3 blendOverlay(vec3 base, vec3 blend, float opacity) {\\n\\treturn (blendOverlay(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n// Hard light\\n\\nvec3 blendHardLight(vec3 base, vec3 blend) {\\n\\treturn blendOverlay(blend,base);\\n}\\n\\nvec3 blendHardLight(vec3 base, vec3 blend, float opacity) {\\n\\treturn (blendHardLight(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n// Soft light\\n\\nfloat blendSoftLight(float base, float blend) {\\n\\treturn (blend<0.5)?(2.0*base*blend+base*base*(1.0-2.0*blend)):(sqrt(base)*(2.0*blend-1.0)+2.0*base*(1.0-blend));\\n}\\n\\nvec3 blendSoftLight(vec3 base, vec3 blend) {\\n\\treturn vec3(blendSoftLight(base.r,blend.r),blendSoftLight(base.g,blend.g),blendSoftLight(base.b,blend.b));\\n}\\n\\nvec3 blendSoftLight(vec3 base, vec3 blend, float opacity) {\\n\\treturn (blendSoftLight(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n// Color dodge\\n\\nfloat blendColorDodge(float base, float blend) {\\n\\treturn (blend==1.0)?blend:min(base/(1.0-blend),1.0);\\n}\\n\\nvec3 blendColorDodge(vec3 base, vec3 blend) {\\n\\treturn vec3(blendColorDodge(base.r,blend.r),blendColorDodge(base.g,blend.g),blendColorDodge(base.b,blend.b));\\n}\\n\\nvec3 blendColorDodge(vec3 base, vec3 blend, float opacity) {\\n\\treturn (blendColorDodge(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n// Color burn\\n\\nfloat blendColorBurn(float base, float blend) {\\n\\treturn (blend==0.0)?blend:max((1.0-((1.0-base)/blend)),0.0);\\n}\\n\\nvec3 blendColorBurn(vec3 base, vec3 blend) {\\n\\treturn vec3(blendColorBurn(base.r,blend.r),blendColorBurn(base.g,blend.g),blendColorBurn(base.b,blend.b));\\n}\\n\\nvec3 blendColorBurn(vec3 base, vec3 blend, float opacity) {\\n\\treturn (blendColorBurn(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n// Vivid Light\\n\\nfloat blendVividLight(float base, float blend) {\\n\\treturn (blend<0.5)?blendColorBurn(base,(2.0*blend)):blendColorDodge(base,(2.0*(blend-0.5)));\\n}\\n\\nvec3 blendVividLight(vec3 base, vec3 blend) {\\n\\treturn vec3(blendVividLight(base.r,blend.r),blendVividLight(base.g,blend.g),blendVividLight(base.b,blend.b));\\n}\\n\\nvec3 blendVividLight(vec3 base, vec3 blend, float opacity) {\\n\\treturn (blendVividLight(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n// Lighten\\n\\nfloat blendLighten(float base, float blend) {\\n\\treturn max(blend,base);\\n}\\n\\nvec3 blendLighten(vec3 base, vec3 blend) {\\n\\treturn vec3(blendLighten(base.r,blend.r),blendLighten(base.g,blend.g),blendLighten(base.b,blend.b));\\n}\\n\\nvec3 blendLighten(vec3 base, vec3 blend, float opacity) {\\n\\treturn (blendLighten(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n// Linear burn\\n\\nfloat blendLinearBurn(float base, float blend) {\\n\\t// Note : Same implementation as BlendSubtractf\\n\\treturn max(base+blend-1.0,0.0);\\n}\\n\\nvec3 blendLinearBurn(vec3 base, vec3 blend) {\\n\\t// Note : Same implementation as BlendSubtract\\n\\treturn max(base+blend-vec3(1.0),vec3(0.0));\\n}\\n\\nvec3 blendLinearBurn(vec3 base, vec3 blend, float opacity) {\\n\\treturn (blendLinearBurn(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n// Linear dodge\\n\\nfloat blendLinearDodge(float base, float blend) {\\n\\t// Note : Same implementation as BlendAddf\\n\\treturn min(base+blend,1.0);\\n}\\n\\nvec3 blendLinearDodge(vec3 base, vec3 blend) {\\n\\t// Note : Same implementation as BlendAdd\\n\\treturn min(base+blend,vec3(1.0));\\n}\\n\\nvec3 blendLinearDodge(vec3 base, vec3 blend, float opacity) {\\n\\treturn (blendLinearDodge(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n// Linear light\\n\\nfloat blendLinearLight(float base, float blend) {\\n\\treturn blend<0.5?blendLinearBurn(base,(2.0*blend)):blendLinearDodge(base,(2.0*(blend-0.5)));\\n}\\n\\nvec3 blendLinearLight(vec3 base, vec3 blend) {\\n\\treturn vec3(blendLinearLight(base.r,blend.r),blendLinearLight(base.g,blend.g),blendLinearLight(base.b,blend.b));\\n}\\n\\nvec3 blendLinearLight(vec3 base, vec3 blend, float opacity) {\\n\\treturn (blendLinearLight(base, blend) * opacity + base * (1.0 - opacity));\\n}\",\n          fragment: \"varying vec3 v_color;\\n\\nvoid main() {\\n  vec3 color = v_color;\\n  if (u_darken_top == 1.0) {\\n    vec2 st = gl_FragCoord.xy/resolution.xy;\\n    color.g -= pow(st.y + sin(-12.0) * st.x, u_shadow_power) * 0.4;\\n  }\\n  gl_FragColor = vec4(color, 1.0);\\n}\"\n      },\n      this.conf = {\n          presetName: \"\",\n          wireframe: false,\n          density: [.06, .16],\n          zoom: 1,\n          rotation: 0,\n          playing: true\n      }, \n      document.querySelectorAll(\"canvas\").length < 1 ? console.log(\"DID NOT LOAD HERO STRIPE CANVAS\") : (\n        \n        this.minigl = new MiniGl(this.el, null, null, !0), \n        requestAnimationFrame(() => {\n            this.el && (this.computedCanvasStyle = getComputedStyle(this.el), this.waitForCssVars())\n        })\n        /*\n        this.scrollObserver = await s.create(.1, !1),\n        this.scrollObserver.observe(this.el),\n        this.scrollObserver.onSeparate(() => {\n            window.removeEventListener(\"scroll\", this.handleScroll), window.removeEventListener(\"mousedown\", this.handleMouseDown), window.removeEventListener(\"mouseup\", this.handleMouseUp), window.removeEventListener(\"keydown\", this.handleKeyDown), this.isIntersecting = !1, this.conf.playing && this.pause()\n        }), \n        this.scrollObserver.onIntersect(() => {\n            window.addEventListener(\"scroll\", this.handleScroll), window.addEventListener(\"mousedown\", this.handleMouseDown), window.addEventListener(\"mouseup\", this.handleMouseUp), window.addEventListener(\"keydown\", this.handleKeyDown), this.isIntersecting = !0, this.addIsLoadedClass(), this.play()\n        })*/\n\n      )\n  }\n  disconnect() {\n      this.scrollObserver && (window.removeEventListener(\"scroll\", this.handleScroll), window.removeEventListener(\"mousedown\", this.handleMouseDown), window.removeEventListener(\"mouseup\", this.handleMouseUp), window.removeEventListener(\"keydown\", this.handleKeyDown), this.scrollObserver.disconnect()), window.removeEventListener(\"resize\", this.resize)\n  }\n  initMaterial() {\n      this.uniforms = {\n          u_time: new this.minigl.Uniform({\n              value: 0\n          }),\n          u_shadow_power: new this.minigl.Uniform({\n              value: 5\n          }),\n          u_darken_top: new this.minigl.Uniform({\n              value: \"\" === this.el.dataset.jsDarkenTop ? 1 : 0\n          }),\n          u_active_colors: new this.minigl.Uniform({\n              value: this.activeColors,\n              type: \"vec4\"\n          }),\n          u_global: new this.minigl.Uniform({\n              value: {\n                  noiseFreq: new this.minigl.Uniform({\n                      value: [this.freqX, this.freqY],\n                      type: \"vec2\"\n                  }),\n                  noiseSpeed: new this.minigl.Uniform({\n                      value: 5e-6\n                  })\n              },\n              type: \"struct\"\n          }),\n          u_vertDeform: new this.minigl.Uniform({\n              value: {\n                  incline: new this.minigl.Uniform({\n                      value: Math.sin(this.angle) / Math.cos(this.angle)\n                  }),\n                  offsetTop: new this.minigl.Uniform({\n                      value: -.5\n                  }),\n                  offsetBottom: new this.minigl.Uniform({\n                      value: -.5\n                  }),\n                  noiseFreq: new this.minigl.Uniform({\n                      value: [3, 4],\n                      type: \"vec2\"\n                  }),\n                  noiseAmp: new this.minigl.Uniform({\n                      value: this.amp\n                  }),\n                  noiseSpeed: new this.minigl.Uniform({\n                      value: 10\n                  }),\n                  noiseFlow: new this.minigl.Uniform({\n                      value: 3\n                  }),\n                  noiseSeed: new this.minigl.Uniform({\n                      value: this.seed\n                  })\n              },\n              type: \"struct\",\n              excludeFrom: \"fragment\"\n          }),\n          u_baseColor: new this.minigl.Uniform({\n              value: this.sectionColors[0],\n              type: \"vec3\",\n              excludeFrom: \"fragment\"\n          }),\n          u_waveLayers: new this.minigl.Uniform({\n              value: [],\n              excludeFrom: \"fragment\",\n              type: \"array\"\n          })\n      };\n      for (let e = 1; e < this.sectionColors.length; e += 1) this.uniforms.u_waveLayers.value.push(new this.minigl.Uniform({\n          value: {\n              color: new this.minigl.Uniform({\n                  value: this.sectionColors[e],\n                  type: \"vec3\"\n              }),\n              noiseFreq: new this.minigl.Uniform({\n                  value: [2 + e / this.sectionColors.length, 3 + e / this.sectionColors.length],\n                  type: \"vec2\"\n              }),\n              noiseSpeed: new this.minigl.Uniform({\n                  value: 11 + .3 * e\n              }),\n              noiseFlow: new this.minigl.Uniform({\n                  value: 6.5 + .3 * e\n              }),\n              noiseSeed: new this.minigl.Uniform({\n                  value: this.seed + 10 * e\n              }),\n              noiseFloor: new this.minigl.Uniform({\n                  value: .1\n              }),\n              noiseCeil: new this.minigl.Uniform({\n                  value: .63 + .07 * e\n              })\n          },\n          type: \"struct\"\n      }));\n      return this.vertexShader = [this.shaderFiles.noise, this.shaderFiles.blend, this.shaderFiles.vertex].join(\"\\n\\n\"), new this.minigl.Material(this.vertexShader, this.shaderFiles.fragment, this.uniforms)\n  }\n  initMesh() {\n      this.material = this.initMaterial(), this.geometry = new this.minigl.PlaneGeometry, this.mesh = new this.minigl.Mesh(this.geometry, this.material)\n  }\n  shouldSkipFrame(e) {\n      return !!window.document.hidden || (!this.conf.playing || (parseInt(e, 10) % 2 == 0 || void 0))\n  }\n  updateFrequency(e) {\n      this.freqX += e, this.freqY += e\n  }\n  toggleColor(index) {\n      this.activeColors[index] = 0 === this.activeColors[index] ? 1 : 0\n  }\n  showGradientLegend() {\n      this.width > this.minWidth && (this.isGradientLegendVisible = !0, document.body.classList.add(\"isGradientLegendVisible\"))\n  }\n  hideGradientLegend() {\n      this.isGradientLegendVisible = !1, document.body.classList.remove(\"isGradientLegendVisible\")\n  }\n  init() {\n      this.initGradientColors(), this.initMesh(), this.resize(), requestAnimationFrame(this.animate), window.addEventListener(\"resize\", this.resize)\n  }\n  /*\n  * Waiting for the css variables to become available, usually on page load before we can continue.\n  * Using default colors assigned below if no variables have been found after maxCssVarRetries\n  */\n  waitForCssVars() {\n      if (this.computedCanvasStyle && -1 !== this.computedCanvasStyle.getPropertyValue(\"--gradient-color-1\").indexOf(\"#\")) this.init(), this.addIsLoadedClass();\n      else {\n          if (this.cssVarRetries += 1, this.cssVarRetries > this.maxCssVarRetries) {\n              return this.sectionColors = [16711680, 16711680, 16711935, 65280, 255],void this.init();\n          }\n          requestAnimationFrame(() => this.waitForCssVars())\n      }\n  }\n  /*\n  * Initializes the four section colors by retrieving them from css variables.\n  */\n  initGradientColors() {\n      this.sectionColors = [\"--gradient-color-1\", \"--gradient-color-2\", \"--gradient-color-3\", \"--gradient-color-4\"].map(cssPropertyName => {\n          let hex = this.computedCanvasStyle.getPropertyValue(cssPropertyName).trim();\n          //Check if shorthand hex value was used and double the length so the conversion in normalizeColor will work.\n          if (4 === hex.length) {\n              const hexTemp = hex.substr(1).split(\"\").map(hexTemp => hexTemp + hexTemp).join(\"\");\n              hex = `#${hexTemp}`\n          }\n          return hex && `0x${hex.substr(1)}`\n      }).filter(Boolean).map(normalizeColor)\n  }\n}\n\n\n\n\n/*\n*Finally initializing the Gradient class, assigning a canvas to it and calling Gradient.connect() which initializes everything,\n* Use Gradient.pause() and Gradient.play() for controls.\n*\n* Here are some default property values you can change anytime:\n* Amplitude:    Gradient.amp = 0\n* Colors:       Gradient.sectionColors (if you change colors, use normalizeColor(#hexValue)) before you assign it.\n*\n*\n* Useful functions\n* Gradient.toggleColor(index)\n* Gradient.updateFrequency(freq)\n*/\nvar gradient = new Gradient();\n    gradient.initGradient(\"#gradient-canvas\");"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}