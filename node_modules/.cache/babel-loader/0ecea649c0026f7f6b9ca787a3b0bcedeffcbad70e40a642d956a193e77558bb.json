{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.resolveRequestDocument = exports.GraphQLWebSocketClient = exports.gql = exports.batchRequests = exports.request = exports.rawRequest = exports.GraphQLClient = exports.ClientError = void 0;\nconst createRequestBody_js_1 = __importDefault(require(\"./createRequestBody.js\"));\nconst defaultJsonSerializer_js_1 = require(\"./defaultJsonSerializer.js\");\nconst helpers_js_1 = require(\"./helpers.js\");\nconst parseArgs_js_1 = require(\"./parseArgs.js\");\nconst resolveRequestDocument_js_1 = require(\"./resolveRequestDocument.js\");\nconst types_js_1 = require(\"./types.js\");\nObject.defineProperty(exports, \"ClientError\", {\n  enumerable: true,\n  get: function () {\n    return types_js_1.ClientError;\n  }\n});\nconst cross_fetch_1 = __importStar(require(\"cross-fetch\")),\n  CrossFetch = cross_fetch_1;\n/**\n * Convert the given headers configuration into a plain object.\n */\nconst resolveHeaders = headers => {\n  let oHeaders = {};\n  if (headers) {\n    if (typeof Headers !== `undefined` && headers instanceof Headers || CrossFetch && CrossFetch.Headers && headers instanceof CrossFetch.Headers) {\n      oHeaders = (0, helpers_js_1.HeadersInstanceToPlainObject)(headers);\n    } else if (Array.isArray(headers)) {\n      headers.forEach(_ref => {\n        let [name, value] = _ref;\n        if (name && value !== undefined) {\n          oHeaders[name] = value;\n        }\n      });\n    } else {\n      oHeaders = headers;\n    }\n  }\n  return oHeaders;\n};\n/**\n * Clean a GraphQL document to send it via a GET query\n */\nconst cleanQuery = str => str.replace(/([\\s,]|#[^\\n\\r]+)+/g, ` `).trim();\n/**\n * Create query string for GraphQL request\n */\nconst buildRequestConfig = params => {\n  if (!Array.isArray(params.query)) {\n    const params_ = params;\n    const search = [`query=${encodeURIComponent(cleanQuery(params_.query))}`];\n    if (params.variables) {\n      search.push(`variables=${encodeURIComponent(params_.jsonSerializer.stringify(params_.variables))}`);\n    }\n    if (params_.operationName) {\n      search.push(`operationName=${encodeURIComponent(params_.operationName)}`);\n    }\n    return search.join(`&`);\n  }\n  if (typeof params.variables !== `undefined` && !Array.isArray(params.variables)) {\n    throw new Error(`Cannot create query with given variable type, array expected`);\n  }\n  // Batch support\n  const params_ = params;\n  const payload = params.query.reduce((acc, currentQuery, index) => {\n    acc.push({\n      query: cleanQuery(currentQuery),\n      variables: params_.variables ? params_.jsonSerializer.stringify(params_.variables[index]) : undefined\n    });\n    return acc;\n  }, []);\n  return `query=${encodeURIComponent(params_.jsonSerializer.stringify(payload))}`;\n};\nconst createHttpMethodFetcher = method => async params => {\n  const {\n    url,\n    query,\n    variables,\n    operationName,\n    fetch,\n    fetchOptions,\n    middleware\n  } = params;\n  const headers = {\n    ...params.headers\n  };\n  let queryParams = ``;\n  let body = undefined;\n  if (method === `POST`) {\n    body = (0, createRequestBody_js_1.default)(query, variables, operationName, fetchOptions.jsonSerializer);\n    if (typeof body === `string`) {\n      // @ts-expect-error todo\n      headers[`Content-Type`] = `application/json`;\n    }\n  } else {\n    // @ts-expect-error todo needs ADT for TS to understand the different states\n    queryParams = buildRequestConfig({\n      query,\n      variables,\n      operationName,\n      jsonSerializer: fetchOptions.jsonSerializer ?? defaultJsonSerializer_js_1.defaultJsonSerializer\n    });\n  }\n  const init = {\n    method,\n    headers,\n    body,\n    ...fetchOptions\n  };\n  let urlResolved = url;\n  let initResolved = init;\n  if (middleware) {\n    const result = await Promise.resolve(middleware({\n      ...init,\n      url,\n      operationName,\n      variables\n    }));\n    const {\n      url: urlNew,\n      ...initNew\n    } = result;\n    urlResolved = urlNew;\n    initResolved = initNew;\n  }\n  if (queryParams) {\n    urlResolved = `${urlResolved}?${queryParams}`;\n  }\n  return await fetch(urlResolved, initResolved);\n};\n/**\n * GraphQL Client.\n */\nclass GraphQLClient {\n  constructor(url) {\n    var _this = this;\n    let requestConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.url = url;\n    this.requestConfig = requestConfig;\n    /**\n     * Send a GraphQL query to the server.\n     */\n    this.rawRequest = async function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      const [queryOrOptions, variables, requestHeaders] = args;\n      const rawRequestOptions = (0, parseArgs_js_1.parseRawRequestArgs)(queryOrOptions, variables, requestHeaders);\n      const {\n        headers,\n        fetch = cross_fetch_1.default,\n        method = `POST`,\n        requestMiddleware,\n        responseMiddleware,\n        ...fetchOptions\n      } = _this.requestConfig;\n      const {\n        url\n      } = _this;\n      if (rawRequestOptions.signal !== undefined) {\n        fetchOptions.signal = rawRequestOptions.signal;\n      }\n      const {\n        operationName\n      } = (0, resolveRequestDocument_js_1.resolveRequestDocument)(rawRequestOptions.query);\n      return makeRequest({\n        url,\n        query: rawRequestOptions.query,\n        variables: rawRequestOptions.variables,\n        headers: {\n          ...resolveHeaders(callOrIdentity(headers)),\n          ...resolveHeaders(rawRequestOptions.requestHeaders)\n        },\n        operationName,\n        fetch,\n        method,\n        fetchOptions,\n        middleware: requestMiddleware\n      }).then(response => {\n        if (responseMiddleware) {\n          responseMiddleware(response);\n        }\n        return response;\n      }).catch(error => {\n        if (responseMiddleware) {\n          responseMiddleware(error);\n        }\n        throw error;\n      });\n    };\n  }\n  async request(documentOrOptions) {\n    for (var _len2 = arguments.length, variablesAndRequestHeaders = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      variablesAndRequestHeaders[_key2 - 1] = arguments[_key2];\n    }\n    const [variables, requestHeaders] = variablesAndRequestHeaders;\n    const requestOptions = (0, parseArgs_js_1.parseRequestArgs)(documentOrOptions, variables, requestHeaders);\n    const {\n      headers,\n      fetch = cross_fetch_1.default,\n      method = `POST`,\n      requestMiddleware,\n      responseMiddleware,\n      ...fetchOptions\n    } = this.requestConfig;\n    const {\n      url\n    } = this;\n    if (requestOptions.signal !== undefined) {\n      fetchOptions.signal = requestOptions.signal;\n    }\n    const {\n      query,\n      operationName\n    } = (0, resolveRequestDocument_js_1.resolveRequestDocument)(requestOptions.document);\n    return makeRequest({\n      url,\n      query,\n      variables: requestOptions.variables,\n      headers: {\n        ...resolveHeaders(callOrIdentity(headers)),\n        ...resolveHeaders(requestOptions.requestHeaders)\n      },\n      operationName,\n      fetch,\n      method,\n      fetchOptions,\n      middleware: requestMiddleware\n    }).then(response => {\n      if (responseMiddleware) {\n        responseMiddleware(response);\n      }\n      return response.data;\n    }).catch(error => {\n      if (responseMiddleware) {\n        responseMiddleware(error);\n      }\n      throw error;\n    });\n  }\n  // prettier-ignore\n  batchRequests(documentsOrOptions, requestHeaders) {\n    const batchRequestOptions = (0, parseArgs_js_1.parseBatchRequestArgs)(documentsOrOptions, requestHeaders);\n    const {\n      headers,\n      ...fetchOptions\n    } = this.requestConfig;\n    if (batchRequestOptions.signal !== undefined) {\n      fetchOptions.signal = batchRequestOptions.signal;\n    }\n    const queries = batchRequestOptions.documents.map(_ref2 => {\n      let {\n        document\n      } = _ref2;\n      return (0, resolveRequestDocument_js_1.resolveRequestDocument)(document).query;\n    });\n    const variables = batchRequestOptions.documents.map(_ref3 => {\n      let {\n        variables\n      } = _ref3;\n      return variables;\n    });\n    return makeRequest({\n      url: this.url,\n      query: queries,\n      // @ts-expect-error TODO reconcile batch variables into system.\n      variables,\n      headers: {\n        ...resolveHeaders(callOrIdentity(headers)),\n        ...resolveHeaders(batchRequestOptions.requestHeaders)\n      },\n      operationName: undefined,\n      fetch: this.requestConfig.fetch ?? cross_fetch_1.default,\n      method: this.requestConfig.method || `POST`,\n      fetchOptions,\n      middleware: this.requestConfig.requestMiddleware\n    }).then(response => {\n      if (this.requestConfig.responseMiddleware) {\n        this.requestConfig.responseMiddleware(response);\n      }\n      return response.data;\n    }).catch(error => {\n      if (this.requestConfig.responseMiddleware) {\n        this.requestConfig.responseMiddleware(error);\n      }\n      throw error;\n    });\n  }\n  setHeaders(headers) {\n    this.requestConfig.headers = headers;\n    return this;\n  }\n  /**\n   * Attach a header to the client. All subsequent requests will have this header.\n   */\n  setHeader(key, value) {\n    const {\n      headers\n    } = this.requestConfig;\n    if (headers) {\n      // todo what if headers is in nested array form... ?\n      //@ts-ignore\n      headers[key] = value;\n    } else {\n      this.requestConfig.headers = {\n        [key]: value\n      };\n    }\n    return this;\n  }\n  /**\n   * Change the client endpoint. All subsequent requests will send to this endpoint.\n   */\n  setEndpoint(value) {\n    this.url = value;\n    return this;\n  }\n}\nexports.GraphQLClient = GraphQLClient;\nconst makeRequest = async params => {\n  const {\n    query,\n    variables,\n    fetchOptions\n  } = params;\n  const fetcher = createHttpMethodFetcher((0, helpers_js_1.uppercase)(params.method ?? `post`));\n  const isBatchingQuery = Array.isArray(params.query);\n  const response = await fetcher(params);\n  const result = await getResult(response, fetchOptions.jsonSerializer ?? defaultJsonSerializer_js_1.defaultJsonSerializer);\n  const successfullyReceivedData = Array.isArray(result) ? !result.some(_ref4 => {\n    let {\n      data\n    } = _ref4;\n    return !data;\n  }) : Boolean(result.data);\n  const successfullyPassedErrorPolicy = Array.isArray(result) || !result.errors || Array.isArray(result.errors) && !result.errors.length || fetchOptions.errorPolicy === `all` || fetchOptions.errorPolicy === `ignore`;\n  if (response.ok && successfullyPassedErrorPolicy && successfullyReceivedData) {\n    // @ts-expect-error TODO fixme\n    const {\n      errors,\n      ...rest\n    } = Array.isArray(result) ? result : result;\n    const data = fetchOptions.errorPolicy === `ignore` ? rest : result;\n    const dataEnvelope = isBatchingQuery ? {\n      data\n    } : data;\n    // @ts-expect-error TODO\n    return {\n      ...dataEnvelope,\n      headers: response.headers,\n      status: response.status\n    };\n  } else {\n    const errorResult = typeof result === `string` ? {\n      error: result\n    } : result;\n    throw new types_js_1.ClientError(\n    // @ts-expect-error TODO\n    {\n      ...errorResult,\n      status: response.status,\n      headers: response.headers\n    }, {\n      query,\n      variables\n    });\n  }\n};\n/**\n * Send a GraphQL Query to the GraphQL server for execution.\n */\nconst rawRequest = async function () {\n  for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n    args[_key3] = arguments[_key3];\n  }\n  const [urlOrOptions, query, ...variablesAndRequestHeaders] = args;\n  const requestOptions = (0, parseArgs_js_1.parseRawRequestExtendedArgs)(urlOrOptions, query, ...variablesAndRequestHeaders);\n  const client = new GraphQLClient(requestOptions.url);\n  return client.rawRequest({\n    ...requestOptions\n  });\n};\nexports.rawRequest = rawRequest;\nasync function request(urlOrOptions,\n// @ts-ignore\ndocument) {\n  for (var _len4 = arguments.length, variablesAndRequestHeaders = new Array(_len4 > 2 ? _len4 - 2 : 0), _key4 = 2; _key4 < _len4; _key4++) {\n    variablesAndRequestHeaders[_key4 - 2] = arguments[_key4];\n  }\n  // @ts-ignore\n  const requestOptions = (0, parseArgs_js_1.parseRequestExtendedArgs)(urlOrOptions, document, ...variablesAndRequestHeaders);\n  const client = new GraphQLClient(requestOptions.url);\n  return client.request({\n    ...requestOptions\n  });\n}\nexports.request = request;\n/**\n * Send a batch of GraphQL Document to the GraphQL server for execution.\n *\n * @example\n *\n * ```ts\n * // You can pass a raw string\n *\n * await batchRequests('https://foo.bar/graphql', [\n * {\n *  query: `\n *   {\n *     query {\n *       users\n *     }\n *   }`\n * },\n * {\n *   query: `\n *   {\n *     query {\n *       users\n *     }\n *   }`\n * }])\n *\n * // You can also pass a GraphQL DocumentNode as query. Convenient if you\n * // are using graphql-tag package.\n *\n * import gql from 'graphql-tag'\n *\n * await batchRequests('https://foo.bar/graphql', [{ query: gql`...` }])\n * ```\n */\nconst batchRequests = async function () {\n  for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n    args[_key5] = arguments[_key5];\n  }\n  const params = parseBatchRequestsArgsExtended(args);\n  const client = new GraphQLClient(params.url);\n  return client.batchRequests(params);\n};\nexports.batchRequests = batchRequests;\nconst parseBatchRequestsArgsExtended = args => {\n  if (args.length === 1) {\n    return args[0];\n  } else {\n    return {\n      url: args[0],\n      documents: args[1],\n      requestHeaders: args[2],\n      signal: undefined\n    };\n  }\n};\nexports.default = request;\nconst getResult = async (response, jsonSerializer) => {\n  let contentType;\n  response.headers.forEach((value, key) => {\n    if (key.toLowerCase() === `content-type`) {\n      contentType = value;\n    }\n  });\n  if (contentType && (contentType.toLowerCase().startsWith(`application/json`) || contentType.toLowerCase().startsWith(`application/graphql+json`) || contentType.toLowerCase().startsWith(`application/graphql-response+json`))) {\n    return jsonSerializer.parse(await response.text());\n  } else {\n    return response.text();\n  }\n};\nconst callOrIdentity = value => {\n  return typeof value === `function` ? value() : value;\n};\n/**\n * Convenience passthrough template tag to get the benefits of tooling for the gql template tag. This does not actually parse the input into a GraphQL DocumentNode like graphql-tag package does. It just returns the string with any variables given interpolated. Can save you a bit of performance and having to install another package.\n *\n * @example\n *\n * import { gql } from 'graphql-request'\n *\n * await request('https://foo.bar/graphql', gql`...`)\n *\n * @remarks\n *\n * Several tools in the Node GraphQL ecosystem are hardcoded to specially treat any template tag named \"gql\". For example see this prettier issue: https://github.com/prettier/prettier/issues/4360. Using this template tag has no runtime effect beyond variable interpolation.\n */\nconst gql = function (chunks) {\n  for (var _len6 = arguments.length, variables = new Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {\n    variables[_key6 - 1] = arguments[_key6];\n  }\n  return chunks.reduce((accumulator, chunk, index) => `${accumulator}${chunk}${index in variables ? variables[index] : ``}`, ``);\n};\nexports.gql = gql;\nvar graphql_ws_js_1 = require(\"./graphql-ws.js\");\nObject.defineProperty(exports, \"GraphQLWebSocketClient\", {\n  enumerable: true,\n  get: function () {\n    return graphql_ws_js_1.GraphQLWebSocketClient;\n  }\n});\nvar resolveRequestDocument_js_2 = require(\"./resolveRequestDocument.js\");\nObject.defineProperty(exports, \"resolveRequestDocument\", {\n  enumerable: true,\n  get: function () {\n    return resolveRequestDocument_js_2.resolveRequestDocument;\n  }\n});","map":{"version":3,"names":["createRequestBody_js_1","__importDefault","require","defaultJsonSerializer_js_1","helpers_js_1","parseArgs_js_1","resolveRequestDocument_js_1","types_js_1","Object","defineProperty","exports","enumerable","get","ClientError","cross_fetch_1","__importStar","CrossFetch","resolveHeaders","headers","oHeaders","Headers","HeadersInstanceToPlainObject","Array","isArray","forEach","_ref","name","value","undefined","cleanQuery","str","replace","trim","buildRequestConfig","params","query","params_","search","encodeURIComponent","variables","push","jsonSerializer","stringify","operationName","join","Error","payload","reduce","acc","currentQuery","index","createHttpMethodFetcher","method","url","fetch","fetchOptions","middleware","queryParams","body","default","defaultJsonSerializer","init","urlResolved","initResolved","result","Promise","resolve","urlNew","initNew","GraphQLClient","constructor","_this","requestConfig","arguments","length","rawRequest","_len","args","_key","queryOrOptions","requestHeaders","rawRequestOptions","parseRawRequestArgs","requestMiddleware","responseMiddleware","signal","resolveRequestDocument","makeRequest","callOrIdentity","then","response","catch","error","request","documentOrOptions","_len2","variablesAndRequestHeaders","_key2","requestOptions","parseRequestArgs","document","data","batchRequests","documentsOrOptions","batchRequestOptions","parseBatchRequestArgs","queries","documents","map","_ref2","_ref3","setHeaders","setHeader","key","setEndpoint","fetcher","uppercase","isBatchingQuery","getResult","successfullyReceivedData","some","_ref4","Boolean","successfullyPassedErrorPolicy","errors","errorPolicy","ok","rest","dataEnvelope","status","errorResult","_len3","_key3","urlOrOptions","parseRawRequestExtendedArgs","client","_len4","_key4","parseRequestExtendedArgs","_len5","_key5","parseBatchRequestsArgsExtended","contentType","toLowerCase","startsWith","parse","text","gql","chunks","_len6","_key6","accumulator","chunk","graphql_ws_js_1","GraphQLWebSocketClient","resolveRequestDocument_js_2"],"sources":["/Users/charlesbuckley/coding/uniswap-v3-subgraph/node_modules/graphql-request/src/index.ts"],"sourcesContent":["import createRequestBody from './createRequestBody.js'\nimport { defaultJsonSerializer } from './defaultJsonSerializer.js'\nimport { HeadersInstanceToPlainObject, uppercase } from './helpers.js'\nimport {\n  parseBatchRequestArgs,\n  parseRawRequestArgs,\n  parseRawRequestExtendedArgs,\n  parseRequestArgs,\n  parseRequestExtendedArgs,\n} from './parseArgs.js'\nimport { resolveRequestDocument } from './resolveRequestDocument.js'\nimport type * as Dom from './types.dom.js'\nimport type {\n  HTTPMethodInput,\n  MaybeFunction,\n  RequestConfig,\n  RequestMiddleware,\n  Response,\n  VariablesAndRequestHeadersArgs,\n} from './types.js'\nimport {\n  BatchRequestDocument,\n  BatchRequestsExtendedOptions,\n  BatchRequestsOptions,\n  ClientError,\n  RawRequestExtendedOptions,\n  RawRequestOptions,\n  RequestDocument,\n  RequestExtendedOptions,\n  RequestOptions,\n  Variables,\n} from './types.js'\nimport type { TypedDocumentNode } from '@graphql-typed-document-node/core'\nimport crossFetch, * as CrossFetch from 'cross-fetch'\nimport type { T, V } from 'vitest/dist/types-7cd96283.js'\n\nexport {\n  BatchRequestDocument,\n  BatchRequestsExtendedOptions,\n  BatchRequestsOptions,\n  ClientError,\n  RawRequestExtendedOptions,\n  RawRequestOptions,\n  RequestDocument,\n  RequestExtendedOptions,\n  RequestOptions,\n  Variables,\n}\n\n/**\n * Convert the given headers configuration into a plain object.\n */\nconst resolveHeaders = (headers: Dom.RequestInit['headers']): Record<string, string> => {\n  let oHeaders: Record<string, string> = {}\n  if (headers) {\n    if (\n      (typeof Headers !== `undefined` && headers instanceof Headers) ||\n      (CrossFetch && CrossFetch.Headers && headers instanceof CrossFetch.Headers)\n    ) {\n      oHeaders = HeadersInstanceToPlainObject(headers)\n    } else if (Array.isArray(headers)) {\n      headers.forEach(([name, value]) => {\n        if (name && value !== undefined) {\n          oHeaders[name] = value\n        }\n      })\n    } else {\n      oHeaders = headers as Record<string, string>\n    }\n  }\n\n  return oHeaders\n}\n\n/**\n * Clean a GraphQL document to send it via a GET query\n */\nconst cleanQuery = (str: string): string => str.replace(/([\\s,]|#[^\\n\\r]+)+/g, ` `).trim()\n\ntype BuildRequestConfigParamsBatch<V> = {\n  query: string[]\n  variables: V[] | undefined\n  operationName: undefined\n  jsonSerializer: Dom.JsonSerializer\n}\n\ntype BuildRequestConfigParamsSingle<V> = {\n  query: string\n  variables: V | undefined\n  operationName: string | undefined\n  jsonSerializer: Dom.JsonSerializer\n}\n\ntype BuildRequestConfigParams<V> = BuildRequestConfigParamsSingle<V> | BuildRequestConfigParamsBatch<V>\n\n/**\n * Create query string for GraphQL request\n */\nconst buildRequestConfig = <V extends Variables>(params: BuildRequestConfigParams<V>): string => {\n  if (!Array.isArray(params.query)) {\n    const params_ = params as BuildRequestConfigParamsSingle<V>\n    const search: string[] = [`query=${encodeURIComponent(cleanQuery(params_.query))}`]\n\n    if (params.variables) {\n      search.push(`variables=${encodeURIComponent(params_.jsonSerializer.stringify(params_.variables))}`)\n    }\n\n    if (params_.operationName) {\n      search.push(`operationName=${encodeURIComponent(params_.operationName)}`)\n    }\n\n    return search.join(`&`)\n  }\n\n  if (typeof params.variables !== `undefined` && !Array.isArray(params.variables)) {\n    throw new Error(`Cannot create query with given variable type, array expected`)\n  }\n\n  // Batch support\n  const params_ = params as BuildRequestConfigParamsBatch<V>\n  const payload = params.query.reduce<{ query: string; variables: string | undefined }[]>(\n    (acc, currentQuery, index) => {\n      acc.push({\n        query: cleanQuery(currentQuery),\n        variables: params_.variables ? params_.jsonSerializer.stringify(params_.variables[index]) : undefined,\n      })\n      return acc\n    },\n    []\n  )\n\n  return `query=${encodeURIComponent(params_.jsonSerializer.stringify(payload))}`\n}\n\ntype Fetch = (url: string, config: Dom.RequestInit) => Promise<Dom.Response>\n\ninterface RequestVerbParams<V extends Variables = Variables> {\n  url: string\n  query: string | string[]\n  fetch: Fetch\n  fetchOptions: Dom.RequestInit\n  variables?: V\n  headers?: Dom.RequestInit['headers']\n  operationName?: string\n  middleware?: RequestMiddleware<V>\n}\n\nconst createHttpMethodFetcher =\n  (method: 'GET' | 'POST') =>\n  async <V extends Variables>(params: RequestVerbParams<V>) => {\n    const { url, query, variables, operationName, fetch, fetchOptions, middleware } = params\n\n    const headers = { ...params.headers }\n    let queryParams = ``\n    let body = undefined\n\n    if (method === `POST`) {\n      body = createRequestBody(query, variables, operationName, fetchOptions.jsonSerializer)\n      if (typeof body === `string`) {\n        // @ts-expect-error todo\n        headers[`Content-Type`] = `application/json`\n      }\n    } else {\n      // @ts-expect-error todo needs ADT for TS to understand the different states\n      queryParams = buildRequestConfig<V>({\n        query,\n        variables,\n        operationName,\n        jsonSerializer: fetchOptions.jsonSerializer ?? defaultJsonSerializer,\n      })\n    }\n\n    const init: Dom.RequestInit = {\n      method,\n      headers,\n      body,\n      ...fetchOptions,\n    }\n\n    let urlResolved = url\n    let initResolved = init\n    if (middleware) {\n      const result = await Promise.resolve(middleware({ ...init, url, operationName, variables }))\n      const { url: urlNew, ...initNew } = result\n      urlResolved = urlNew\n      initResolved = initNew\n    }\n    if (queryParams) {\n      urlResolved = `${urlResolved}?${queryParams}`\n    }\n    return await fetch(urlResolved, initResolved)\n  }\n\n/**\n * GraphQL Client.\n */\nexport class GraphQLClient {\n  constructor(private url: string, public readonly requestConfig: RequestConfig = {}) {}\n\n  /**\n   * Send a GraphQL query to the server.\n   */\n  rawRequest: RawRequestMethod = async <T, V extends Variables = Variables>(\n    ...args: RawRequestMethodArgs<V>\n  ): Promise<Response<T>> => {\n    const [queryOrOptions, variables, requestHeaders] = args\n    const rawRequestOptions = parseRawRequestArgs<V>(queryOrOptions, variables, requestHeaders)\n\n    const {\n      headers,\n      fetch = crossFetch,\n      method = `POST`,\n      requestMiddleware,\n      responseMiddleware,\n      ...fetchOptions\n    } = this.requestConfig\n    const { url } = this\n    if (rawRequestOptions.signal !== undefined) {\n      fetchOptions.signal = rawRequestOptions.signal\n    }\n\n    const { operationName } = resolveRequestDocument(rawRequestOptions.query)\n\n    return makeRequest<T, V>({\n      url,\n      query: rawRequestOptions.query,\n      variables: rawRequestOptions.variables as V,\n      headers: {\n        ...resolveHeaders(callOrIdentity(headers)),\n        ...resolveHeaders(rawRequestOptions.requestHeaders),\n      },\n      operationName,\n      fetch,\n      method,\n      fetchOptions,\n      middleware: requestMiddleware,\n    })\n      .then((response) => {\n        if (responseMiddleware) {\n          responseMiddleware(response)\n        }\n        return response\n      })\n      .catch((error) => {\n        if (responseMiddleware) {\n          responseMiddleware(error)\n        }\n        throw error\n      })\n  }\n\n  /**\n   * Send a GraphQL document to the server.\n   */\n  async request<T, V extends Variables = Variables>(\n    document: RequestDocument | TypedDocumentNode<T, V>,\n    ...variablesAndRequestHeaders: VariablesAndRequestHeadersArgs<V>\n  ): Promise<T>\n  async request<T, V extends Variables = Variables>(options: RequestOptions<V, T>): Promise<T>\n  async request<T, V extends Variables = Variables>(\n    documentOrOptions: RequestDocument | TypedDocumentNode<T, V> | RequestOptions<V>,\n    ...variablesAndRequestHeaders: VariablesAndRequestHeadersArgs<V>\n  ): Promise<T> {\n    const [variables, requestHeaders] = variablesAndRequestHeaders\n    const requestOptions = parseRequestArgs(documentOrOptions, variables, requestHeaders)\n\n    const {\n      headers,\n      fetch = crossFetch,\n      method = `POST`,\n      requestMiddleware,\n      responseMiddleware,\n      ...fetchOptions\n    } = this.requestConfig\n    const { url } = this\n    if (requestOptions.signal !== undefined) {\n      fetchOptions.signal = requestOptions.signal\n    }\n\n    const { query, operationName } = resolveRequestDocument(requestOptions.document)\n\n    return makeRequest<T>({\n      url,\n      query,\n      variables: requestOptions.variables,\n      headers: {\n        ...resolveHeaders(callOrIdentity(headers)),\n        ...resolveHeaders(requestOptions.requestHeaders),\n      },\n      operationName,\n      fetch,\n      method,\n      fetchOptions,\n      middleware: requestMiddleware,\n    })\n      .then((response) => {\n        if (responseMiddleware) {\n          responseMiddleware(response)\n        }\n        return response.data\n      })\n      .catch((error) => {\n        if (responseMiddleware) {\n          responseMiddleware(error)\n        }\n        throw error\n      })\n  }\n\n  /**\n   * Send GraphQL documents in batch to the server.\n   */\n  // prettier-ignore\n  batchRequests<T extends BatchResult, V extends Variables = Variables>(documents: BatchRequestDocument<V>[], requestHeaders?: Dom.RequestInit['headers']): Promise<T>\n  // prettier-ignore\n  batchRequests<T extends BatchResult, V extends Variables = Variables>(options: BatchRequestsOptions<V>): Promise<T>\n  // prettier-ignore\n  batchRequests<T extends BatchResult, V extends Variables = Variables>(\n    documentsOrOptions: BatchRequestDocument<V>[] | BatchRequestsOptions<V>,\n    requestHeaders?: Dom.RequestInit['headers']\n  ): Promise<T> {\n    const batchRequestOptions = parseBatchRequestArgs<V>(documentsOrOptions, requestHeaders)\n    const { headers, ...fetchOptions } = this.requestConfig\n\n    if (batchRequestOptions.signal !== undefined) {\n      fetchOptions.signal = batchRequestOptions.signal\n    }\n\n    const queries = batchRequestOptions.documents.map(\n      ({ document }) => resolveRequestDocument(document).query\n    )\n    const variables = batchRequestOptions.documents.map(({ variables }) => variables)\n\n    return makeRequest<T>({\n      url: this.url,\n      query: queries,\n      // @ts-expect-error TODO reconcile batch variables into system.\n      variables,\n      headers: {\n        ...resolveHeaders(callOrIdentity(headers)),\n        ...resolveHeaders(batchRequestOptions.requestHeaders),\n      },\n      operationName: undefined,\n      fetch: this.requestConfig.fetch ?? crossFetch,\n      method: this.requestConfig.method || `POST`,\n      fetchOptions,\n      middleware: this.requestConfig.requestMiddleware,\n    })\n      .then((response) => {\n        if (this.requestConfig.responseMiddleware) {\n          this.requestConfig.responseMiddleware(response)\n        }\n        return response.data\n      })\n      .catch((error) => {\n        if (this.requestConfig.responseMiddleware) {\n          this.requestConfig.responseMiddleware(error)\n        }\n        throw error\n      })\n  }\n\n  setHeaders(headers: Dom.RequestInit['headers']): GraphQLClient {\n    this.requestConfig.headers = headers\n    return this\n  }\n\n  /**\n   * Attach a header to the client. All subsequent requests will have this header.\n   */\n  setHeader(key: string, value: string): GraphQLClient {\n    const { headers } = this.requestConfig\n\n    if (headers) {\n      // todo what if headers is in nested array form... ?\n      //@ts-ignore\n      headers[key] = value\n    } else {\n      this.requestConfig.headers = { [key]: value }\n    }\n\n    return this\n  }\n\n  /**\n   * Change the client endpoint. All subsequent requests will send to this endpoint.\n   */\n  setEndpoint(value: string): GraphQLClient {\n    this.url = value\n    return this\n  }\n}\n\nconst makeRequest = async <T = unknown, V extends Variables = Variables>(params: {\n  url: string\n  query: string | string[]\n  variables?: V\n  headers?: Dom.RequestInit['headers']\n  operationName?: string\n  fetch: Fetch\n  method?: HTTPMethodInput\n  fetchOptions: Dom.RequestInit\n  middleware?: RequestMiddleware<V>\n}): Promise<Response<T>> => {\n  const { query, variables, fetchOptions } = params\n  const fetcher = createHttpMethodFetcher(uppercase(params.method ?? `post`))\n  const isBatchingQuery = Array.isArray(params.query)\n  const response = await fetcher(params)\n  const result = await getResult(response, fetchOptions.jsonSerializer ?? defaultJsonSerializer)\n\n  const successfullyReceivedData = Array.isArray(result)\n    ? !result.some(({ data }) => !data)\n    : Boolean(result.data)\n\n  const successfullyPassedErrorPolicy =\n    Array.isArray(result) ||\n    !result.errors ||\n    (Array.isArray(result.errors) && !result.errors.length) ||\n    fetchOptions.errorPolicy === `all` ||\n    fetchOptions.errorPolicy === `ignore`\n\n  if (response.ok && successfullyPassedErrorPolicy && successfullyReceivedData) {\n    // @ts-expect-error TODO fixme\n    const { errors, ...rest } = Array.isArray(result) ? result : result\n    const data = fetchOptions.errorPolicy === `ignore` ? rest : result\n    const dataEnvelope = isBatchingQuery ? { data } : data\n\n    // @ts-expect-error TODO\n    return {\n      ...dataEnvelope,\n      headers: response.headers,\n      status: response.status,\n    }\n  } else {\n    const errorResult =\n      typeof result === `string`\n        ? {\n            error: result,\n          }\n        : result\n    throw new ClientError(\n      // @ts-expect-error TODO\n      { ...errorResult, status: response.status, headers: response.headers },\n      { query, variables }\n    )\n  }\n}\n\n// prettier-ignore\ninterface RawRequestMethod {\n  <T, V extends Variables = Variables>(query: string, variables?: V, requestHeaders?: Dom.RequestInit['headers']): Promise<Response<T>>\n  <T, V extends Variables = Variables>(options: RawRequestOptions<V>): Promise<Response<T>>\n}\n\n// prettier-ignore\ntype RawRequestMethodArgs<V extends Variables> =\n  | [query: string, variables?: V, requestHeaders?: Dom.RequestInit['headers']]\n  | [RawRequestOptions<V>]\n\n// prettier-ignore\ninterface RawRequest {\n  <T, V extends Variables = Variables>(url: string, query: string, ...variablesAndRequestHeaders: VariablesAndRequestHeadersArgs<V>): Promise<Response<T>>\n  <T, V extends Variables = Variables>(options: RawRequestExtendedOptions<V>): Promise<Response<T>>\n}\n\n// prettier-ignore\ntype RawRequestArgs<V extends Variables> = \n  | [options: RawRequestExtendedOptions<V>, query?: string, ...variablesAndRequestHeaders: VariablesAndRequestHeadersArgs<V>]\n  | [url: string,                           query?: string, ...variablesAndRequestHeaders: VariablesAndRequestHeadersArgs<V>]\n\n/**\n * Send a GraphQL Query to the GraphQL server for execution.\n */\nexport const rawRequest: RawRequest = async <T, V extends Variables>(\n  ...args: RawRequestArgs<V>\n): Promise<Response<T>> => {\n  const [urlOrOptions, query, ...variablesAndRequestHeaders] = args\n  const requestOptions = parseRawRequestExtendedArgs<V>(urlOrOptions, query, ...variablesAndRequestHeaders)\n  const client = new GraphQLClient(requestOptions.url)\n  return client.rawRequest<T, V>({\n    ...requestOptions,\n  })\n}\n\n/**\n * Send a GraphQL Document to the GraphQL server for execution.\n *\n * @example\n *\n * ```ts\n * // You can pass a raw string\n *\n * await request('https://foo.bar/graphql', `\n *   {\n *     query {\n *       users\n *     }\n *   }\n * `)\n *\n * // You can also pass a GraphQL DocumentNode. Convenient if you\n * // are using graphql-tag package.\n *\n * import gql from 'graphql-tag'\n *\n * await request('https://foo.bar/graphql', gql`...`)\n *\n * // If you don't actually care about using DocumentNode but just\n * // want the tooling support for gql template tag like IDE syntax\n * // coloring and prettier autoformat then note you can use the\n * // passthrough gql tag shipped with graphql-request to save a bit\n * // of performance and not have to install another dep into your project.\n *\n * import { gql } from 'graphql-request'\n *\n * await request('https://foo.bar/graphql', gql`...`)\n * ```\n */\nexport async function request<T, V extends Variables = Variables>(\n  url: string,\n  // @ts-ignore\n  document: RequestDocument | TypedDocumentNode<T, V>,\n  ...variablesAndRequestHeaders: VariablesAndRequestHeadersArgs<V>\n): Promise<T>\nexport async function request<T, V extends Variables = Variables>(\n  options: RequestExtendedOptions<V, T>\n): Promise<T>\nexport async function request<T, V extends Variables = Variables>(\n  urlOrOptions: string | RequestExtendedOptions<V, T>,\n  // @ts-ignore\n  document?: RequestDocument | TypedDocumentNode<T, V>,\n  ...variablesAndRequestHeaders: VariablesAndRequestHeadersArgs<V>\n): Promise<T> {\n  // @ts-ignore\n  const requestOptions = parseRequestExtendedArgs<V>(urlOrOptions, document, ...variablesAndRequestHeaders)\n  const client = new GraphQLClient(requestOptions.url)\n  return client.request<T, V>({\n    ...requestOptions,\n  })\n}\n\n/**\n * Send a batch of GraphQL Document to the GraphQL server for execution.\n *\n * @example\n *\n * ```ts\n * // You can pass a raw string\n *\n * await batchRequests('https://foo.bar/graphql', [\n * {\n *  query: `\n *   {\n *     query {\n *       users\n *     }\n *   }`\n * },\n * {\n *   query: `\n *   {\n *     query {\n *       users\n *     }\n *   }`\n * }])\n *\n * // You can also pass a GraphQL DocumentNode as query. Convenient if you\n * // are using graphql-tag package.\n *\n * import gql from 'graphql-tag'\n *\n * await batchRequests('https://foo.bar/graphql', [{ query: gql`...` }])\n * ```\n */\nexport const batchRequests: BatchRequests = async (...args: BatchRequestsArgs) => {\n  const params = parseBatchRequestsArgsExtended(args)\n  const client = new GraphQLClient(params.url)\n  return client.batchRequests(params)\n}\n\ninterface Result<Data extends object = object> {\n  data: Data\n}\n\ntype BatchResult = [Result, ...Result[]]\n\n// prettier-ignore\ninterface BatchRequests {\n  <T extends BatchResult, V extends Variables = Variables>(url: string, documents: BatchRequestDocument<V>[], requestHeaders?: Dom.RequestInit['headers']): Promise<T>\n  <T extends BatchResult, V extends Variables = Variables>(options: BatchRequestsExtendedOptions<V>): Promise<T>\n}\n\ntype BatchRequestsArgs =\n  | [url: string, documents: BatchRequestDocument[], requestHeaders?: Dom.RequestInit['headers']]\n  | [options: BatchRequestsExtendedOptions]\n\nconst parseBatchRequestsArgsExtended = (args: BatchRequestsArgs): BatchRequestsExtendedOptions => {\n  if (args.length === 1) {\n    return args[0]\n  } else {\n    return {\n      url: args[0],\n      documents: args[1],\n      requestHeaders: args[2],\n      signal: undefined,\n    }\n  }\n}\n\nexport default request\n\nconst getResult = async (\n  response: Dom.Response,\n  jsonSerializer: Dom.JsonSerializer\n): Promise<\n  | { data: object; errors: undefined }[]\n  | { data: object; errors: undefined }\n  | { data: undefined; errors: object }\n  | { data: undefined; errors: object[] }\n> => {\n  let contentType: string | undefined\n\n  response.headers.forEach((value, key) => {\n    if (key.toLowerCase() === `content-type`) {\n      contentType = value\n    }\n  })\n\n  if (\n    contentType &&\n    (contentType.toLowerCase().startsWith(`application/json`) ||\n      contentType.toLowerCase().startsWith(`application/graphql+json`) ||\n      contentType.toLowerCase().startsWith(`application/graphql-response+json`))\n  ) {\n    return jsonSerializer.parse(await response.text()) as any\n  } else {\n    return response.text() as any\n  }\n}\n\nconst callOrIdentity = <T>(value: MaybeFunction<T>) => {\n  return typeof value === `function` ? (value as () => T)() : value\n}\n\n/**\n * Convenience passthrough template tag to get the benefits of tooling for the gql template tag. This does not actually parse the input into a GraphQL DocumentNode like graphql-tag package does. It just returns the string with any variables given interpolated. Can save you a bit of performance and having to install another package.\n *\n * @example\n *\n * import { gql } from 'graphql-request'\n *\n * await request('https://foo.bar/graphql', gql`...`)\n *\n * @remarks\n *\n * Several tools in the Node GraphQL ecosystem are hardcoded to specially treat any template tag named \"gql\". For example see this prettier issue: https://github.com/prettier/prettier/issues/4360. Using this template tag has no runtime effect beyond variable interpolation.\n */\nexport const gql = (chunks: TemplateStringsArray, ...variables: any[]): string => {\n  return chunks.reduce(\n    (accumulator, chunk, index) => `${accumulator}${chunk}${index in variables ? variables[index] : ``}`,\n    ``\n  )\n}\n\nexport { GraphQLWebSocketClient } from './graphql-ws.js'\nexport { resolveRequestDocument } from './resolveRequestDocument.js'\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,MAAAA,sBAAA,GAAAC,eAAA,CAAAC,OAAA;AACA,MAAAC,0BAAA,GAAAD,OAAA;AACA,MAAAE,YAAA,GAAAF,OAAA;AACA,MAAAG,cAAA,GAAAH,OAAA;AAOA,MAAAI,2BAAA,GAAAJ,OAAA;AAUA,MAAAK,UAAA,GAAAL,OAAA;AAoBEM,MAAA,CAAAC,cAAA,CAAAC,OAAA;EAAAC,UAAA;EAAAC,GAAA,WAAAA,CAAA;IAAA,OAhBAL,UAAA,CAAAM,WAAW;EAAA;AAAA;AASb,MAAAC,aAAA,GAAAC,YAAA,CAAAb,OAAA;EAAAc,UAAA,GAAAF,aAAA;AAgBA;;;AAGA,MAAMG,cAAc,GAAIC,OAAmC,IAA4B;EACrF,IAAIC,QAAQ,GAA2B,EAAE;EACzC,IAAID,OAAO,EAAE;IACX,IACG,OAAOE,OAAO,KAAK,WAAW,IAAIF,OAAO,YAAYE,OAAO,IAC5DJ,UAAU,IAAIA,UAAU,CAACI,OAAO,IAAIF,OAAO,YAAYF,UAAU,CAACI,OAAQ,EAC3E;MACAD,QAAQ,GAAG,IAAAf,YAAA,CAAAiB,4BAA4B,EAACH,OAAO,CAAC;KACjD,MAAM,IAAII,KAAK,CAACC,OAAO,CAACL,OAAO,CAAC,EAAE;MACjCA,OAAO,CAACM,OAAO,CAACC,IAAA,IAAkB;QAAA,IAAjB,CAACC,IAAI,EAAEC,KAAK,CAAC,GAAAF,IAAA;QAC5B,IAAIC,IAAI,IAAIC,KAAK,KAAKC,SAAS,EAAE;UAC/BT,QAAQ,CAACO,IAAI,CAAC,GAAGC,KAAK;;MAE1B,CAAC,CAAC;KACH,MAAM;MACLR,QAAQ,GAAGD,OAAiC;;;EAIhD,OAAOC,QAAQ;AACjB,CAAC;AAED;;;AAGA,MAAMU,UAAU,GAAIC,GAAW,IAAaA,GAAG,CAACC,OAAO,CAAC,qBAAqB,EAAE,GAAG,CAAC,CAACC,IAAI,EAAE;AAkB1F;;;AAGA,MAAMC,kBAAkB,GAAyBC,MAAmC,IAAY;EAC9F,IAAI,CAACZ,KAAK,CAACC,OAAO,CAACW,MAAM,CAACC,KAAK,CAAC,EAAE;IAChC,MAAMC,OAAO,GAAGF,MAA2C;IAC3D,MAAMG,MAAM,GAAa,CAAC,SAASC,kBAAkB,CAACT,UAAU,CAACO,OAAO,CAACD,KAAK,CAAC,CAAC,EAAE,CAAC;IAEnF,IAAID,MAAM,CAACK,SAAS,EAAE;MACpBF,MAAM,CAACG,IAAI,CAAC,aAAaF,kBAAkB,CAACF,OAAO,CAACK,cAAc,CAACC,SAAS,CAACN,OAAO,CAACG,SAAS,CAAC,CAAC,EAAE,CAAC;;IAGrG,IAAIH,OAAO,CAACO,aAAa,EAAE;MACzBN,MAAM,CAACG,IAAI,CAAC,iBAAiBF,kBAAkB,CAACF,OAAO,CAACO,aAAa,CAAC,EAAE,CAAC;;IAG3E,OAAON,MAAM,CAACO,IAAI,CAAC,GAAG,CAAC;;EAGzB,IAAI,OAAOV,MAAM,CAACK,SAAS,KAAK,WAAW,IAAI,CAACjB,KAAK,CAACC,OAAO,CAACW,MAAM,CAACK,SAAS,CAAC,EAAE;IAC/E,MAAM,IAAIM,KAAK,CAAC,8DAA8D,CAAC;;EAGjF;EACA,MAAMT,OAAO,GAAGF,MAA0C;EAC1D,MAAMY,OAAO,GAAGZ,MAAM,CAACC,KAAK,CAACY,MAAM,CACjC,CAACC,GAAG,EAAEC,YAAY,EAAEC,KAAK,KAAI;IAC3BF,GAAG,CAACR,IAAI,CAAC;MACPL,KAAK,EAAEN,UAAU,CAACoB,YAAY,CAAC;MAC/BV,SAAS,EAAEH,OAAO,CAACG,SAAS,GAAGH,OAAO,CAACK,cAAc,CAACC,SAAS,CAACN,OAAO,CAACG,SAAS,CAACW,KAAK,CAAC,CAAC,GAAGtB;KAC7F,CAAC;IACF,OAAOoB,GAAG;EACZ,CAAC,EACD,EAAE,CACH;EAED,OAAO,SAASV,kBAAkB,CAACF,OAAO,CAACK,cAAc,CAACC,SAAS,CAACI,OAAO,CAAC,CAAC,EAAE;AACjF,CAAC;AAeD,MAAMK,uBAAuB,GAC1BC,MAAsB,IACvB,MAA4BlB,MAA4B,IAAI;EAC1D,MAAM;IAAEmB,GAAG;IAAElB,KAAK;IAAEI,SAAS;IAAEI,aAAa;IAAEW,KAAK;IAAEC,YAAY;IAAEC;EAAU,CAAE,GAAGtB,MAAM;EAExF,MAAMhB,OAAO,GAAG;IAAE,GAAGgB,MAAM,CAAChB;EAAO,CAAE;EACrC,IAAIuC,WAAW,GAAG,EAAE;EACpB,IAAIC,IAAI,GAAG9B,SAAS;EAEpB,IAAIwB,MAAM,KAAK,MAAM,EAAE;IACrBM,IAAI,GAAG,IAAA1D,sBAAA,CAAA2D,OAAiB,EAACxB,KAAK,EAAEI,SAAS,EAAEI,aAAa,EAAEY,YAAY,CAACd,cAAc,CAAC;IACtF,IAAI,OAAOiB,IAAI,KAAK,QAAQ,EAAE;MAC5B;MACAxC,OAAO,CAAC,cAAc,CAAC,GAAG,kBAAkB;;GAE/C,MAAM;IACL;IACAuC,WAAW,GAAGxB,kBAAkB,CAAI;MAClCE,KAAK;MACLI,SAAS;MACTI,aAAa;MACbF,cAAc,EAAEc,YAAY,CAACd,cAAc,IAAItC,0BAAA,CAAAyD;KAChD,CAAC;;EAGJ,MAAMC,IAAI,GAAoB;IAC5BT,MAAM;IACNlC,OAAO;IACPwC,IAAI;IACJ,GAAGH;GACJ;EAED,IAAIO,WAAW,GAAGT,GAAG;EACrB,IAAIU,YAAY,GAAGF,IAAI;EACvB,IAAIL,UAAU,EAAE;IACd,MAAMQ,MAAM,GAAG,MAAMC,OAAO,CAACC,OAAO,CAACV,UAAU,CAAC;MAAE,GAAGK,IAAI;MAAER,GAAG;MAAEV,aAAa;MAAEJ;IAAS,CAAE,CAAC,CAAC;IAC5F,MAAM;MAAEc,GAAG,EAAEc,MAAM;MAAE,GAAGC;IAAO,CAAE,GAAGJ,MAAM;IAC1CF,WAAW,GAAGK,MAAM;IACpBJ,YAAY,GAAGK,OAAO;;EAExB,IAAIX,WAAW,EAAE;IACfK,WAAW,GAAG,GAAGA,WAAW,IAAIL,WAAW,EAAE;;EAE/C,OAAO,MAAMH,KAAK,CAACQ,WAAW,EAAEC,YAAY,CAAC;AAC/C,CAAC;AAEH;;;AAGA,MAAaM,aAAa;EACxBC,YAAoBjB,GAAW,EAAmD;IAAA,IAAAkB,KAAA;IAAA,IAAjCC,aAAA,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAA7C,SAAA,GAAA6C,SAAA,MAA+B,EAAE;IAA9D,KAAApB,GAAG,GAAHA,GAAG;IAA0B,KAAAmB,aAAa,GAAbA,aAAa;IAE9D;;;IAGA,KAAAG,UAAU,GAAqB,kBAEL;MAAA,SAAAC,IAAA,GAAAH,SAAA,CAAAC,MAAA,EADrBG,IAA6B,OAAAvD,KAAA,CAAAsD,IAAA,GAAAE,IAAA,MAAAA,IAAA,GAAAF,IAAA,EAAAE,IAAA;QAA7BD,IAA6B,CAAAC,IAAA,IAAAL,SAAA,CAAAK,IAAA;MAAA;MAEhC,MAAM,CAACC,cAAc,EAAExC,SAAS,EAAEyC,cAAc,CAAC,GAAGH,IAAI;MACxD,MAAMI,iBAAiB,GAAG,IAAA5E,cAAA,CAAA6E,mBAAmB,EAAIH,cAAc,EAAExC,SAAS,EAAEyC,cAAc,CAAC;MAE3F,MAAM;QACJ9D,OAAO;QACPoC,KAAK,GAAGxC,aAAA,CAAA6C,OAAU;QAClBP,MAAM,GAAG,MAAM;QACf+B,iBAAiB;QACjBC,kBAAkB;QAClB,GAAG7B;MAAY,CAChB,GAAGgB,KAAI,CAACC,aAAa;MACtB,MAAM;QAAEnB;MAAG,CAAE,GAAGkB,KAAI;MACpB,IAAIU,iBAAiB,CAACI,MAAM,KAAKzD,SAAS,EAAE;QAC1C2B,YAAY,CAAC8B,MAAM,GAAGJ,iBAAiB,CAACI,MAAM;;MAGhD,MAAM;QAAE1C;MAAa,CAAE,GAAG,IAAArC,2BAAA,CAAAgF,sBAAsB,EAACL,iBAAiB,CAAC9C,KAAK,CAAC;MAEzE,OAAOoD,WAAW,CAAO;QACvBlC,GAAG;QACHlB,KAAK,EAAE8C,iBAAiB,CAAC9C,KAAK;QAC9BI,SAAS,EAAE0C,iBAAiB,CAAC1C,SAAc;QAC3CrB,OAAO,EAAE;UACP,GAAGD,cAAc,CAACuE,cAAc,CAACtE,OAAO,CAAC,CAAC;UAC1C,GAAGD,cAAc,CAACgE,iBAAiB,CAACD,cAAc;SACnD;QACDrC,aAAa;QACbW,KAAK;QACLF,MAAM;QACNG,YAAY;QACZC,UAAU,EAAE2B;OACb,CAAC,CACCM,IAAI,CAAEC,QAAQ,IAAI;QACjB,IAAIN,kBAAkB,EAAE;UACtBA,kBAAkB,CAACM,QAAQ,CAAC;;QAE9B,OAAOA,QAAQ;MACjB,CAAC,CAAC,CACDC,KAAK,CAAEC,KAAK,IAAI;QACf,IAAIR,kBAAkB,EAAE;UACtBA,kBAAkB,CAACQ,KAAK,CAAC;;QAE3B,MAAMA,KAAK;MACb,CAAC,CAAC;IACN,CAAC;EApDoF;EA8DrF,MAAMC,OAAOA,CACXC,iBAAgF,EAChB;IAAA,SAAAC,KAAA,GAAAtB,SAAA,CAAAC,MAAA,EAA7DsB,0BAA6D,OAAA1E,KAAA,CAAAyE,KAAA,OAAAA,KAAA,WAAAE,KAAA,MAAAA,KAAA,GAAAF,KAAA,EAAAE,KAAA;MAA7DD,0BAA6D,CAAAC,KAAA,QAAAxB,SAAA,CAAAwB,KAAA;IAAA;IAEhE,MAAM,CAAC1D,SAAS,EAAEyC,cAAc,CAAC,GAAGgB,0BAA0B;IAC9D,MAAME,cAAc,GAAG,IAAA7F,cAAA,CAAA8F,gBAAgB,EAACL,iBAAiB,EAAEvD,SAAS,EAAEyC,cAAc,CAAC;IAErF,MAAM;MACJ9D,OAAO;MACPoC,KAAK,GAAGxC,aAAA,CAAA6C,OAAU;MAClBP,MAAM,GAAG,MAAM;MACf+B,iBAAiB;MACjBC,kBAAkB;MAClB,GAAG7B;IAAY,CAChB,GAAG,IAAI,CAACiB,aAAa;IACtB,MAAM;MAAEnB;IAAG,CAAE,GAAG,IAAI;IACpB,IAAI6C,cAAc,CAACb,MAAM,KAAKzD,SAAS,EAAE;MACvC2B,YAAY,CAAC8B,MAAM,GAAGa,cAAc,CAACb,MAAM;;IAG7C,MAAM;MAAElD,KAAK;MAAEQ;IAAa,CAAE,GAAG,IAAArC,2BAAA,CAAAgF,sBAAsB,EAACY,cAAc,CAACE,QAAQ,CAAC;IAEhF,OAAOb,WAAW,CAAI;MACpBlC,GAAG;MACHlB,KAAK;MACLI,SAAS,EAAE2D,cAAc,CAAC3D,SAAS;MACnCrB,OAAO,EAAE;QACP,GAAGD,cAAc,CAACuE,cAAc,CAACtE,OAAO,CAAC,CAAC;QAC1C,GAAGD,cAAc,CAACiF,cAAc,CAAClB,cAAc;OAChD;MACDrC,aAAa;MACbW,KAAK;MACLF,MAAM;MACNG,YAAY;MACZC,UAAU,EAAE2B;KACb,CAAC,CACCM,IAAI,CAAEC,QAAQ,IAAI;MACjB,IAAIN,kBAAkB,EAAE;QACtBA,kBAAkB,CAACM,QAAQ,CAAC;;MAE9B,OAAOA,QAAQ,CAACW,IAAI;IACtB,CAAC,CAAC,CACDV,KAAK,CAAEC,KAAK,IAAI;MACf,IAAIR,kBAAkB,EAAE;QACtBA,kBAAkB,CAACQ,KAAK,CAAC;;MAE3B,MAAMA,KAAK;IACb,CAAC,CAAC;EACN;EASA;EACAU,aAAaA,CACXC,kBAAuE,EACvEvB,cAA2C;IAE3C,MAAMwB,mBAAmB,GAAG,IAAAnG,cAAA,CAAAoG,qBAAqB,EAAIF,kBAAkB,EAAEvB,cAAc,CAAC;IACxF,MAAM;MAAE9D,OAAO;MAAE,GAAGqC;IAAY,CAAE,GAAG,IAAI,CAACiB,aAAa;IAEvD,IAAIgC,mBAAmB,CAACnB,MAAM,KAAKzD,SAAS,EAAE;MAC5C2B,YAAY,CAAC8B,MAAM,GAAGmB,mBAAmB,CAACnB,MAAM;;IAGlD,MAAMqB,OAAO,GAAGF,mBAAmB,CAACG,SAAS,CAACC,GAAG,CAC/CC,KAAA;MAAA,IAAC;QAAET;MAAQ,CAAE,GAAAS,KAAA;MAAA,OAAK,IAAAvG,2BAAA,CAAAgF,sBAAsB,EAACc,QAAQ,CAAC,CAACjE,KAAK;IAAA,EACzD;IACD,MAAMI,SAAS,GAAGiE,mBAAmB,CAACG,SAAS,CAACC,GAAG,CAACE,KAAA;MAAA,IAAC;QAAEvE;MAAS,CAAE,GAAAuE,KAAA;MAAA,OAAKvE,SAAS;IAAA,EAAC;IAEjF,OAAOgD,WAAW,CAAI;MACpBlC,GAAG,EAAE,IAAI,CAACA,GAAG;MACblB,KAAK,EAAEuE,OAAO;MACd;MACAnE,SAAS;MACTrB,OAAO,EAAE;QACP,GAAGD,cAAc,CAACuE,cAAc,CAACtE,OAAO,CAAC,CAAC;QAC1C,GAAGD,cAAc,CAACuF,mBAAmB,CAACxB,cAAc;OACrD;MACDrC,aAAa,EAAEf,SAAS;MACxB0B,KAAK,EAAE,IAAI,CAACkB,aAAa,CAAClB,KAAK,IAAIxC,aAAA,CAAA6C,OAAU;MAC7CP,MAAM,EAAE,IAAI,CAACoB,aAAa,CAACpB,MAAM,IAAI,MAAM;MAC3CG,YAAY;MACZC,UAAU,EAAE,IAAI,CAACgB,aAAa,CAACW;KAChC,CAAC,CACCM,IAAI,CAAEC,QAAQ,IAAI;MACjB,IAAI,IAAI,CAAClB,aAAa,CAACY,kBAAkB,EAAE;QACzC,IAAI,CAACZ,aAAa,CAACY,kBAAkB,CAACM,QAAQ,CAAC;;MAEjD,OAAOA,QAAQ,CAACW,IAAI;IACtB,CAAC,CAAC,CACDV,KAAK,CAAEC,KAAK,IAAI;MACf,IAAI,IAAI,CAACpB,aAAa,CAACY,kBAAkB,EAAE;QACzC,IAAI,CAACZ,aAAa,CAACY,kBAAkB,CAACQ,KAAK,CAAC;;MAE9C,MAAMA,KAAK;IACb,CAAC,CAAC;EACN;EAEAmB,UAAUA,CAAC7F,OAAmC;IAC5C,IAAI,CAACsD,aAAa,CAACtD,OAAO,GAAGA,OAAO;IACpC,OAAO,IAAI;EACb;EAEA;;;EAGA8F,SAASA,CAACC,GAAW,EAAEtF,KAAa;IAClC,MAAM;MAAET;IAAO,CAAE,GAAG,IAAI,CAACsD,aAAa;IAEtC,IAAItD,OAAO,EAAE;MACX;MACA;MACAA,OAAO,CAAC+F,GAAG,CAAC,GAAGtF,KAAK;KACrB,MAAM;MACL,IAAI,CAAC6C,aAAa,CAACtD,OAAO,GAAG;QAAE,CAAC+F,GAAG,GAAGtF;MAAK,CAAE;;IAG/C,OAAO,IAAI;EACb;EAEA;;;EAGAuF,WAAWA,CAACvF,KAAa;IACvB,IAAI,CAAC0B,GAAG,GAAG1B,KAAK;IAChB,OAAO,IAAI;EACb;;AAlMFjB,OAAA,CAAA2D,aAAA,GAAAA,aAAA;AAqMA,MAAMkB,WAAW,GAAG,MAAqDrD,MAUxE,IAA0B;EACzB,MAAM;IAAEC,KAAK;IAAEI,SAAS;IAAEgB;EAAY,CAAE,GAAGrB,MAAM;EACjD,MAAMiF,OAAO,GAAGhE,uBAAuB,CAAC,IAAA/C,YAAA,CAAAgH,SAAS,EAAClF,MAAM,CAACkB,MAAM,IAAI,MAAM,CAAC,CAAC;EAC3E,MAAMiE,eAAe,GAAG/F,KAAK,CAACC,OAAO,CAACW,MAAM,CAACC,KAAK,CAAC;EACnD,MAAMuD,QAAQ,GAAG,MAAMyB,OAAO,CAACjF,MAAM,CAAC;EACtC,MAAM8B,MAAM,GAAG,MAAMsD,SAAS,CAAC5B,QAAQ,EAAEnC,YAAY,CAACd,cAAc,IAAItC,0BAAA,CAAAyD,qBAAqB,CAAC;EAE9F,MAAM2D,wBAAwB,GAAGjG,KAAK,CAACC,OAAO,CAACyC,MAAM,CAAC,GAClD,CAACA,MAAM,CAACwD,IAAI,CAACC,KAAA;IAAA,IAAC;MAAEpB;IAAI,CAAE,GAAAoB,KAAA;IAAA,OAAK,CAACpB,IAAI;EAAA,EAAC,GACjCqB,OAAO,CAAC1D,MAAM,CAACqC,IAAI,CAAC;EAExB,MAAMsB,6BAA6B,GACjCrG,KAAK,CAACC,OAAO,CAACyC,MAAM,CAAC,IACrB,CAACA,MAAM,CAAC4D,MAAM,IACbtG,KAAK,CAACC,OAAO,CAACyC,MAAM,CAAC4D,MAAM,CAAC,IAAI,CAAC5D,MAAM,CAAC4D,MAAM,CAAClD,MAAO,IACvDnB,YAAY,CAACsE,WAAW,KAAK,KAAK,IAClCtE,YAAY,CAACsE,WAAW,KAAK,QAAQ;EAEvC,IAAInC,QAAQ,CAACoC,EAAE,IAAIH,6BAA6B,IAAIJ,wBAAwB,EAAE;IAC5E;IACA,MAAM;MAAEK,MAAM;MAAE,GAAGG;IAAI,CAAE,GAAGzG,KAAK,CAACC,OAAO,CAACyC,MAAM,CAAC,GAAGA,MAAM,GAAGA,MAAM;IACnE,MAAMqC,IAAI,GAAG9C,YAAY,CAACsE,WAAW,KAAK,QAAQ,GAAGE,IAAI,GAAG/D,MAAM;IAClE,MAAMgE,YAAY,GAAGX,eAAe,GAAG;MAAEhB;IAAI,CAAE,GAAGA,IAAI;IAEtD;IACA,OAAO;MACL,GAAG2B,YAAY;MACf9G,OAAO,EAAEwE,QAAQ,CAACxE,OAAO;MACzB+G,MAAM,EAAEvC,QAAQ,CAACuC;KAClB;GACF,MAAM;IACL,MAAMC,WAAW,GACf,OAAOlE,MAAM,KAAK,QAAQ,GACtB;MACE4B,KAAK,EAAE5B;KACR,GACDA,MAAM;IACZ,MAAM,IAAIzD,UAAA,CAAAM,WAAW;IACnB;IACA;MAAE,GAAGqH,WAAW;MAAED,MAAM,EAAEvC,QAAQ,CAACuC,MAAM;MAAE/G,OAAO,EAAEwE,QAAQ,CAACxE;IAAO,CAAE,EACtE;MAAEiB,KAAK;MAAEI;IAAS,CAAE,CACrB;;AAEL,CAAC;AAwBD;;;AAGO,MAAMoC,UAAU,GAAe,eAAAA,CAAA,EAEZ;EAAA,SAAAwD,KAAA,GAAA1D,SAAA,CAAAC,MAAA,EADrBG,IAAuB,OAAAvD,KAAA,CAAA6G,KAAA,GAAAC,KAAA,MAAAA,KAAA,GAAAD,KAAA,EAAAC,KAAA;IAAvBvD,IAAuB,CAAAuD,KAAA,IAAA3D,SAAA,CAAA2D,KAAA;EAAA;EAE1B,MAAM,CAACC,YAAY,EAAElG,KAAK,EAAE,GAAG6D,0BAA0B,CAAC,GAAGnB,IAAI;EACjE,MAAMqB,cAAc,GAAG,IAAA7F,cAAA,CAAAiI,2BAA2B,EAAID,YAAY,EAAElG,KAAK,EAAE,GAAG6D,0BAA0B,CAAC;EACzG,MAAMuC,MAAM,GAAG,IAAIlE,aAAa,CAAC6B,cAAc,CAAC7C,GAAG,CAAC;EACpD,OAAOkF,MAAM,CAAC5D,UAAU,CAAO;IAC7B,GAAGuB;GACJ,CAAC;AACJ,CAAC;AATYxF,OAAA,CAAAiE,UAAU,GAAAA,UAAA;AAsDhB,eAAekB,OAAOA,CAC3BwC,YAAmD;AACnD;AACAjC,QAAoD,EACY;EAAA,SAAAoC,KAAA,GAAA/D,SAAA,CAAAC,MAAA,EAA7DsB,0BAA6D,OAAA1E,KAAA,CAAAkH,KAAA,OAAAA,KAAA,WAAAC,KAAA,MAAAA,KAAA,GAAAD,KAAA,EAAAC,KAAA;IAA7DzC,0BAA6D,CAAAyC,KAAA,QAAAhE,SAAA,CAAAgE,KAAA;EAAA;EAEhE;EACA,MAAMvC,cAAc,GAAG,IAAA7F,cAAA,CAAAqI,wBAAwB,EAAIL,YAAY,EAAEjC,QAAQ,EAAE,GAAGJ,0BAA0B,CAAC;EACzG,MAAMuC,MAAM,GAAG,IAAIlE,aAAa,CAAC6B,cAAc,CAAC7C,GAAG,CAAC;EACpD,OAAOkF,MAAM,CAAC1C,OAAO,CAAO;IAC1B,GAAGK;GACJ,CAAC;AACJ;AAZAxF,OAAA,CAAAmF,OAAA,GAAAA,OAAA;AAcA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkCO,MAAMS,aAAa,GAAkB,eAAAA,CAAA,EAAqC;EAAA,SAAAqC,KAAA,GAAAlE,SAAA,CAAAC,MAAA,EAA3BG,IAAuB,OAAAvD,KAAA,CAAAqH,KAAA,GAAAC,KAAA,MAAAA,KAAA,GAAAD,KAAA,EAAAC,KAAA;IAAvB/D,IAAuB,CAAA+D,KAAA,IAAAnE,SAAA,CAAAmE,KAAA;EAAA;EAC3E,MAAM1G,MAAM,GAAG2G,8BAA8B,CAAChE,IAAI,CAAC;EACnD,MAAM0D,MAAM,GAAG,IAAIlE,aAAa,CAACnC,MAAM,CAACmB,GAAG,CAAC;EAC5C,OAAOkF,MAAM,CAACjC,aAAa,CAACpE,MAAM,CAAC;AACrC,CAAC;AAJYxB,OAAA,CAAA4F,aAAa,GAAAA,aAAA;AAsB1B,MAAMuC,8BAA8B,GAAIhE,IAAuB,IAAkC;EAC/F,IAAIA,IAAI,CAACH,MAAM,KAAK,CAAC,EAAE;IACrB,OAAOG,IAAI,CAAC,CAAC,CAAC;GACf,MAAM;IACL,OAAO;MACLxB,GAAG,EAAEwB,IAAI,CAAC,CAAC,CAAC;MACZ8B,SAAS,EAAE9B,IAAI,CAAC,CAAC,CAAC;MAClBG,cAAc,EAAEH,IAAI,CAAC,CAAC,CAAC;MACvBQ,MAAM,EAAEzD;KACT;;AAEL,CAAC;AAEDlB,OAAA,CAAAiD,OAAA,GAAekC,OAAO;AAEtB,MAAMyB,SAAS,GAAG,MAAAA,CAChB5B,QAAsB,EACtBjD,cAAkC,KAMhC;EACF,IAAIqG,WAA+B;EAEnCpD,QAAQ,CAACxE,OAAO,CAACM,OAAO,CAAC,CAACG,KAAK,EAAEsF,GAAG,KAAI;IACtC,IAAIA,GAAG,CAAC8B,WAAW,EAAE,KAAK,cAAc,EAAE;MACxCD,WAAW,GAAGnH,KAAK;;EAEvB,CAAC,CAAC;EAEF,IACEmH,WAAW,KACVA,WAAW,CAACC,WAAW,EAAE,CAACC,UAAU,CAAC,kBAAkB,CAAC,IACvDF,WAAW,CAACC,WAAW,EAAE,CAACC,UAAU,CAAC,0BAA0B,CAAC,IAChEF,WAAW,CAACC,WAAW,EAAE,CAACC,UAAU,CAAC,mCAAmC,CAAC,CAAC,EAC5E;IACA,OAAOvG,cAAc,CAACwG,KAAK,CAAC,MAAMvD,QAAQ,CAACwD,IAAI,EAAE,CAAQ;GAC1D,MAAM;IACL,OAAOxD,QAAQ,CAACwD,IAAI,EAAS;;AAEjC,CAAC;AAED,MAAM1D,cAAc,GAAO7D,KAAuB,IAAI;EACpD,OAAO,OAAOA,KAAK,KAAK,UAAU,GAAIA,KAAiB,EAAE,GAAGA,KAAK;AACnE,CAAC;AAED;;;;;;;;;;;;;AAaO,MAAMwH,GAAG,GAAG,SAAAA,CAACC,MAA4B,EAAiC;EAAA,SAAAC,KAAA,GAAA5E,SAAA,CAAAC,MAAA,EAA5BnC,SAAgB,OAAAjB,KAAA,CAAA+H,KAAA,OAAAA,KAAA,WAAAC,KAAA,MAAAA,KAAA,GAAAD,KAAA,EAAAC,KAAA;IAAhB/G,SAAgB,CAAA+G,KAAA,QAAA7E,SAAA,CAAA6E,KAAA;EAAA;EACnE,OAAOF,MAAM,CAACrG,MAAM,CAClB,CAACwG,WAAW,EAAEC,KAAK,EAAEtG,KAAK,KAAK,GAAGqG,WAAW,GAAGC,KAAK,GAAGtG,KAAK,IAAIX,SAAS,GAAGA,SAAS,CAACW,KAAK,CAAC,GAAG,EAAE,EAAE,EACpG,EAAE,CACH;AACH,CAAC;AALYxC,OAAA,CAAAyI,GAAG,GAAAA,GAAA;AAOhB,IAAAM,eAAA,GAAAvJ,OAAA;AAASM,MAAA,CAAAC,cAAA,CAAAC,OAAA;EAAAC,UAAA;EAAAC,GAAA,WAAAA,CAAA;IAAA,OAAA6I,eAAA,CAAAC,sBAAsB;EAAA;AAAA;AAC/B,IAAAC,2BAAA,GAAAzJ,OAAA;AAASM,MAAA,CAAAC,cAAA,CAAAC,OAAA;EAAAC,UAAA;EAAAC,GAAA,WAAAA,CAAA;IAAA,OAAA+I,2BAAA,CAAArE,sBAAsB;EAAA;AAAA"},"metadata":{},"sourceType":"script","externalDependencies":[]}